<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>IPJ - Datajournalisme</title>
    <meta charset="utf-8" />
    <meta name="author" content="Sylvain Lapoix" />
    <script src="libs/header-attrs-2.25/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

.title[
# IPJ - Datajournalisme
]
.subtitle[
## Jour 2 : Nettoyer, manipuler et visualiser des données en R
]
.author[
### Sylvain Lapoix
]
.date[
### 20/10/2023
]

---



layout: true

&lt;style type="text/css"&gt;

.lr_bg{
  background: black;
  color: #f7c600;
  font-weight: bold;
}

.pull-left-wide {
  width: 65%;
  float: left;
}

.pull-right-wide {
  width: 65%;
  float: right;
}

.pull-right-narrow {
  width: 30%;
  float: right;
}

.pull-left-narrow {
  width: 30%;
  float: left;
}

.quote {
  font-family: 'Rokkitt';
  font-weight: bold;
  font-style: italic;
  font-size: 28px;
}


.yellow-h{
  background: #ffff88;
}

.blue-h{
  background: #83c7fc;
}


.white-h{
   color: #000000;
   background: #FFFFFF;
}

.black-h{
   color: #FFFFFF;
   background: #000000;
}


&lt;/style&gt;

---

background-image: url("https://media.giphy.com/media/fCUCbWXe9JONVsJSUd/giphy.gif")
class: center, top, inverse

# Aujourd'hui, on parle nettoyage !




---

### Aparté : le Rmd 1/2

Comme son nom l'indique, le **Rmd** est un format ajoutant les fonctionnalités de **R** à celles d'un **markdown**.

Sous R, le package `{knitr}` permet de compiler un Rmd en trois formats au choix : PDF, HTML ou docx. Pour ce faire, il suffit de cliquer sur le bouton **Knit** en haut de l'interface Rstudio (ou avec *Ctrl/Cmd + Shift + k*).

#### Côté markdown

Le markdown est un métalangage de mise en forme qui repose sur un système de balisage simple et léger :
* `#` pour un titre de niveau 1 ;
* `##` pour un titre de niveau 2 et ainsi de suite ;
* `*` en balise pour ital, `**` pour la graisse ;
* `[nom](url)` avec le texte entre croches et le lien entre parenthèses pour un hypertexte ;
* `![alt](src)` avec le lien vers l'image pour afficher une image.

---

### Aparté : le Rmd 2/2

#### Côté R

La principale fonctionnalité R est l'intégration de *chunks*, des *"morceaux"*, de code R à l'intérieur d'un Markdown. Le Rmd affiche la sortie des opérations.

Pour ajouter un chunk, vous pouvez utiliser le raccourci *Ctrl/Cmd + Alt + i*.

Certaines fonctions sont spécialement conçues pour les Rmd, comme `kable()` du package `{knitr}`, qui permet un affichage optimal des tables. 

Il est également possible d'afficher les sorties visuelles :
* dataviz ;
* cartes interactives ;
* tableaux interactifs ;
* apps ;
* etc.

---

background-image: url("https://media.giphy.com/media/uWzDsAsRm2X9qULHLs/giphy.gif")
class: center, top, inverse

# 1. Des données "propres"

---

## Pourquoi "nettoyer" ses données ?

Le nettoyage de données, tâche fastidieuse (50 à 80% du temps des professionnelles de la data, [selon un article du NYTimes de 2014](https://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html)), est nécessaire car la plupart des données sont livrées dans le format correspondant aux besoins du/de la producteur·rice et non des réutilisateur·rices.

La notion de "données propres" (*clean data*) se réfère ainsi à l'usage et non pas à un standard universel : **chaque usage d'un jeu de données par un·e utilisateur·rice amènera à des critères de *propreté* différents**.

---

### Quelques principes généraux de nettoyage



Nous pouvons néanmoins énoncer quelques généralités :
* est propre un jeu de données où chaque donnée est lue suivant **le type** attendu ;
* est propre un jeu de données où les valeurs d'une même variable répondent à **une nomenclature** stable et lisible ;
* est propre un jeu de données dont **les variables sont renseignées de manière claire et cohérente** par rapport au schéma général ;
* est propre un jeu de données où **les données utiles sont formattées de manière à pouvoir être manipulées facilement**

Quatre notions clefs vont donc nous servir de guide pour nettoyer nos données : le typage, le nommage, la complétude et le formattage.

---

### Un exemple de structure : les "tidy data"

![](./img/tidydata.png)


.pull-left[Cette structure de base est le modèle proposé par *Hadley Wickham*, créateur du `{tidyverse}`, le modèle **tidy data**.

Cette approche vise à simplifier la lecture et la manipulation des données.]

.pull-right[
.right[
![](./img/hadley.jpg)
]
]




---

## Apprendre à regarder ses données

La première étape du nettoyage consiste à examiner ses données afin d'en connaître les traits généraux : combien de variables ? Combien de valeur par variable ? Quelle est leur distribution ? Quel rapport entretiennent-elles entre elles ? Y a-t-il des valeurs non renseignées ? Etc.

`{R base}` et le `{tidyverse}` offrent de nombreux outils d'exploration préalables qui permettent de créer des aperçus des données.

---

### head() : les premières lignes

Votre premier réflexe face à une base de données, c'est de voir *"comment elle se présente"*. Pour se faire, la fonction `head()` est un bon point d'entrée : elle propose en sortie les 6 premières observations d'un jeu de données.

Pour voir les dernières observations, vous pouvez utiliser sa fonction miroir, `tail()`. Il est possible de paramétrer le nom d'observations affichées en passant à l'argument `n` la valeur correspondante.

Jettons un oeil aux premières lignes du jeu de données 4 du Répertoire national des élu·es (ou RNE) [disponible sur Data.gouv.fr](https://www.data.gouv.fr/en/datasets/repertoire-national-des-elus-1/), consacré aux conseiller·ères régionaux·les :


```r
library(tidyverse)


rne4 &lt;- read_csv("https://www.data.gouv.fr/fr/datasets/r/601ef073-d986-4582-8e1a-ed14dc857fba")

head(rne4)
```

```
## # A tibble: 6 × 13
##   `Code du département` `Libellé du département` `Code du canton`
##   &lt;chr&gt;                 &lt;chr&gt;                    &lt;chr&gt;           
## 1 01                    Ain                      0101            
## 2 01                    Ain                      0101            
## 3 01                    Ain                      0102            
## 4 01                    Ain                      0102            
## 5 01                    Ain                      0103            
## 6 01                    Ain                      0103            
## # ℹ 10 more variables: `Libellé du canton` &lt;chr&gt;, `Nom de l'élu` &lt;chr&gt;,
## #   `Prénom de l'élu` &lt;chr&gt;, `Code sexe` &lt;chr&gt;, `Date de naissance` &lt;chr&gt;,
## #   `Code de la catégorie socio-professionnelle` &lt;dbl&gt;,
## #   `Libellé de la catégorie socio-professionnelle` &lt;chr&gt;,
## #   `Date de début du mandat` &lt;chr&gt;, `Libellé de la fonction` &lt;chr&gt;,
## #   `Date de début de la fonction` &lt;chr&gt;
```

---

### glimpse() : une synthèse des dimensions

Une fois ce premier aperçu parcouru, il est nécessaire de disposer d'une image plus générale. La première étape consiste à regarder les variables du jeu de données et leur type.

Le `{tidyverse}` propose pour cela une fonction très compacte et pratique : `glimpse()`. Quand un jeu de données lui est passé, `glimpse()` produit une synthèse rapide : nombre de ligne, nombre de colonne et premières valeurs pour chacune des variables à disposition ainsi que son type.


```r
glimpse(rne4)
```

```
## Rows: 4,055
## Columns: 13
## $ `Code du département`                           &lt;chr&gt; "01", "01", "01", "01"…
## $ `Libellé du département`                        &lt;chr&gt; "Ain", "Ain", "Ain", "…
## $ `Code du canton`                                &lt;chr&gt; "0101", "0101", "0102"…
## $ `Libellé du canton`                             &lt;chr&gt; "Ambérieu-En-Bugey", "…
## $ `Nom de l'élu`                                  &lt;chr&gt; "BRUNET", "PETIT", "FO…
## $ `Prénom de l'élu`                               &lt;chr&gt; "Joël", "Aurélie", "Cl…
## $ `Code sexe`                                     &lt;chr&gt; "M", "F", "F", "M", "M…
## $ `Date de naissance`                             &lt;chr&gt; "02/05/1955", "29/08/1…
## $ `Code de la catégorie socio-professionnelle`    &lt;dbl&gt; 23, 38, 35, 38, 38, 46…
## $ `Libellé de la catégorie socio-professionnelle` &lt;chr&gt; "Chef d'entreprise de …
## $ `Date de début du mandat`                       &lt;chr&gt; "01/07/2021", "01/07/2…
## $ `Libellé de la fonction`                        &lt;chr&gt; NA, NA, "9ème Vice-pré…
## $ `Date de début de la fonction`                  &lt;chr&gt; NA, NA, "01/07/2021", …
```

---

### summary() : une synthèse des variables

`{rbase}` offre une fonction complémentaire de `glimpse()` avec `summary()`.

`summary()` analyse le jeu de données et, plutôt qu'un aperçu de quelques valeurs, propose une synthèse par variable (notamment des éléments de distribution). A ce titre, **`summary()` s'avère beaucoup plus adapté pour survoler un jeu de données contenant des données numériques que pour les chaînes de caractère**.



```r
summary(rne4)
```

```
##  Code du département Libellé du département Code du canton    
##  Length:4055         Length:4055            Length:4055       
##  Class :character    Class :character       Class :character  
##  Mode  :character    Mode  :character       Mode  :character  
##                                                               
##                                                               
##                                                               
##  Libellé du canton  Nom de l'élu       Prénom de l'élu     Code sexe        
##  Length:4055        Length:4055        Length:4055        Length:4055       
##  Class :character   Class :character   Class :character   Class :character  
##  Mode  :character   Mode  :character   Mode  :character   Mode  :character  
##                                                                             
##                                                                             
##                                                                             
##  Date de naissance  Code de la catégorie socio-professionnelle
##  Length:4055        Min.   : 11.00                            
##  Class :character   1st Qu.: 33.00                            
##  Mode  :character   Median : 42.00                            
##                     Mean   : 48.04                            
##                     3rd Qu.: 74.00                            
##                     Max.   :165.00                            
##  Libellé de la catégorie socio-professionnelle Date de début du mandat
##  Length:4055                                   Length:4055            
##  Class :character                              Class :character       
##  Mode  :character                              Mode  :character       
##                                                                       
##                                                                       
##                                                                       
##  Libellé de la fonction Date de début de la fonction
##  Length:4055            Length:4055                 
##  Class :character       Class :character            
##  Mode  :character       Mode  :character            
##                                                     
##                                                     
## 
```


---

### table() : la distribution sur une variable

La distribution des valeurs est la façon dont l'ensemble des valeurs sont réparties sur la gamme des valeurs possibles dans la base de données. Il s'agit d'un outil d'analyse très utile pour les données numériques mais tout autant pour les chaînes de caractère ou les booléens.

La fonction de `{rbase}` `table()` permet de réaliser une synthèse de la distribution des valeurs pour une variable d'un jeu de données. Elle prend pour argument la base de données suivie de `$nomdelavariable`. Par exemple, si nous souhaitons connaître la distribution des `Libellé de la fonction`, nous pouvons appeler cette fonction de la manière suivante :


```r
rne4 &lt;- rename(rne4, c("fonction"="Libellé de la fonction")) # d'abord, renommons cette variable relou

table(rne4$fonction)
```

```
## 
##    10ème Vice-président du conseil départemental 
##                                               71 
##    11ème Vice-président du conseil départemental 
##                                               55 
##    12ème Vice-président du conseil départemental 
##                                               47 
##    13ème Vice-président du conseil départemental 
##                                               28 
##    14ème Vice-président du conseil départemental 
##                                               20 
##    15ème Vice-président du conseil départemental 
##                                               19 
##      1er Vice-président du conseil départemental 
##                                               92 
##     2ème Vice-président du conseil départemental 
##                                               92 
##     3ème Vice-président du conseil départemental 
##                                               91 
##     4ème Vice-président du conseil départemental 
##                                               93 
##     5ème Vice-président du conseil départemental 
##                                               91 
##     6ème Vice-président du conseil départemental 
##                                               93 
##     7ème Vice-président du conseil départemental 
##                                               92 
##     8ème Vice-président du conseil départemental 
##                                               86 
##     9ème Vice-président du conseil départemental 
##                                               80 
## Président de commission du conseil départemental 
##                                               17 
##               Président du conseil départemental 
##                                               94
```


---

### is.na() : la présence de NAs

Vous n'avez rien remarqué de bizarre dans le précédent compte ?

Comment se fait-il que nous ayons 14 régions mais seulement 13 Premier·ères vice-président·es ?

--

Pour savoir si une valeur correspond à une type de données, `{rbase}` propose une série de fonction de test : `is.*()` : `is.numeric()`, `is.logical()` ... et `is.na()` pour savoir si la valeur est NA ou non.

En la combinant avec `table()`, nous obtenons une synthèse sur le nombre de TRUE et de FALSE :

```r
table(is.na(rne4$fonction))
```

```
## 
## FALSE  TRUE 
##  1161  2894
```

Nous avons donc bien un problème sur cette variable, qu'on dira *"mal renseignée"*.

**Tester une variable avec `is.na()` est une vérification de complétude souvent utile avant d'utiliser une variable.**

---

### Mesurer les éléments

Plusieurs foncitons permettent de connaître la longueur d'un objet dans R :
* `length()` : pour la longueur d'un vecteur ;
* `nrow()` / `ncol()` : pour le nombre de ligne ou colonne d'un dataframe ;
* `nchar()` : pour le nombre de caractères d'une chaîne de caractère.



```r
length(rne4$`Libellé de la région`)
```

```
## [1] 0
```

```r
nrow(rne4)
```

```
## [1] 4055
```

```r
nchar(rne4$`Libellé de la région`)
```

```
## integer(0)
```


---

### Aparté : les tests 1/2

L'informatique repose en grande partie sur les valeurs booléennes : TRUE / FALSE, 1 / 0, etc. Ce type de valeur a de nombreuses qualités : elle s'avère facile à produire, lire, stocker et sans risque d'ambiguïté.

Un *test* est une opération par laquelle une propriété est évaluée sur un objet : si la propriété est remplie, le test sera dit *"vrai"* (*TRUE*), sinon, il sera dit *"faux"* (*FALSE*). Ce sont des questions fermées.

Les tests de base sont réalisés avec les opérateurs dits logiques :
* égalité `==` ;
* supérieur ou égal `&gt;=` / inférieur ou égal `&lt;=` ;
* strictement supérieur `&gt;` / strictement inférieur `&lt;` ;
* différent `!=`.


```r
5 &gt; 2
```

```
## [1] TRUE
```

Il existe de nombreuses fonctions permettant de réaliser des tests (notamment les fonctions `is.*()` évoquées dans la slide précédente).

---

### Aparté : les tests 2/2

La plupart des outils que nous manipulons en R procède par des tests implicites ou explicitent. Nous pourrions résumer le principe par la question :
*"Faut-il appliquer l'opération à l'élément de rang N ?"*

Aquoi l'on peut répondre par oui ou par non.

En R, quand un test est réalisé sur un vecteur, il renvoie un vecteur de même longueur dont chaque valeur est le résultat du test sur la valeur du vecteur d'origine. Par exemple :

```r
vecteur &lt;- c(3,1,9,15,22)
vecteur &gt; 10
```

```
## [1] FALSE FALSE FALSE  TRUE  TRUE
```

---

background-image: url("https://media.giphy.com/media/PmABbbUe3IqUKSOIBV/giphy.gif")
class: center, top, inverse

# 2. Trier et organiser ses données

---

## filter() : pour choisir les observations

La fonction `filter()` du package `{dplyr}` va nous permettre de sélectionner les observation suivant une ou plusieurs conditions.

La fonction `filter()` appelle un ou plusieurs tests portant sur une ou plusieurs variables :


```r
rne4 &lt;- rne4 %&gt;%  setNames(c("region_code","region_nom","dep_code","dep_nom","elu_nom","elu_prenom",
                   "sexe","date_naissance","profession_code","profession_nom","date_mandat",
                   "fonction","fonction_date"))

rne4 %&gt;% filter(sexe == "F")
```

```
## # A tibble: 2,029 × 13
##    region_code region_nom dep_code dep_nom              elu_nom elu_prenom sexe 
##    &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;                &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;
##  1 01          Ain        0101     Ambérieu-En-Bugey    PETIT   Aurélie    F    
##  2 01          Ain        0102     Attignat             FOURNI… Clotilde   F    
##  3 01          Ain        0103     Valserhône           OLLIET  Anne-Laure F    
##  4 01          Ain        0104     Belley               BOREL   Aurélie    F    
##  5 01          Ain        0105     Bourg-En-Bresse-1    BERTRA… Hélène     F    
##  6 01          Ain        0106     Bourg-En-Bresse-2    CÉDILE… Hélène     F    
##  7 01          Ain        0107     Ceyzériat            TABOUR… Martine    F    
##  8 01          Ain        0108     Châtillon-Sur-Chala… CHMARA  Patricia   F    
##  9 01          Ain        0109     Gex                  BAUDE   Véronique  F    
## 10 01          Ain        0110     Plateau d'Hauteville MEURIAU Annie      F    
## # ℹ 2,019 more rows
## # ℹ 6 more variables: date_naissance &lt;chr&gt;, profession_code &lt;dbl&gt;,
## #   profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;, fonction &lt;chr&gt;,
## #   fonction_date &lt;chr&gt;
```


---

### Filtre à conditions multiples

La fonction `filter()` appelle un ou plusieurs tests portant sur une ou plusieurs variables :


```r
rne4 %&gt;% filter(fonction == "Président du conseil régional",
                sexe == "F")
```

```
## # A tibble: 0 × 13
## # ℹ 13 variables: region_code &lt;chr&gt;, region_nom &lt;chr&gt;, dep_code &lt;chr&gt;,
## #   dep_nom &lt;chr&gt;, elu_nom &lt;chr&gt;, elu_prenom &lt;chr&gt;, sexe &lt;chr&gt;,
## #   date_naissance &lt;chr&gt;, profession_code &lt;dbl&gt;, profession_nom &lt;chr&gt;,
## #   date_mandat &lt;chr&gt;, fonction &lt;chr&gt;, fonction_date &lt;chr&gt;
```

---

### L'opérateur %in%

L'opérateur `%in%` permet de réaliser un test avec plusieurs possibilités fournies sous forme d'un vecteur.

Nous pouvons par exemple passer une liste de codes de régions pour en sélectionner plusieurs d'un coup :


```r
rne4 %&gt;% filter(region_code %in% c("11","27","44"))
```

```
## # A tibble: 146 × 13
##    region_code region_nom dep_code dep_nom            elu_nom elu_prenom   sexe 
##    &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;              &lt;chr&gt;   &lt;chr&gt;        &lt;chr&gt;
##  1 11          Aude       1101     La Piège au Razès  BOURREL Marie-Chris… F    
##  2 11          Aude       1101     La Piège au Razès  VIOLA   André        M    
##  3 11          Aude       1102     Carcassonne-1      BARDOU  Magali       F    
##  4 11          Aude       1102     Carcassonne-1      MOURAD  François     M    
##  5 11          Aude       1103     Carcassonne-2      LECINA  Thierry      M    
##  6 11          Aude       1103     Carcassonne-2      RIVEL   Tamara       F    
##  7 11          Aude       1104     Carcassonne-3      CONQUET Maria        F    
##  8 11          Aude       1104     Carcassonne-3      DEDIES  Daniel       M    
##  9 11          Aude       1105     Le Bassin chaurien BRUNEL  Eliane       F    
## 10 11          Aude       1105     Le Bassin chaurien MAUGARD Patrick      M    
## # ℹ 136 more rows
## # ℹ 6 more variables: date_naissance &lt;chr&gt;, profession_code &lt;dbl&gt;,
## #   profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;, fonction &lt;chr&gt;,
## #   fonction_date &lt;chr&gt;
```


---

### L'opérateur "!"

L'opérateur `!`, quand il précède un test, permet d'en inverser les critères et donc de "ne pas" sélectionner les observations qui correspondent au test.

Par exemple, nous pouvons inverser la sélectioner précédente en sélectionnant toutes les régions SAUF celles listées :


```r
rne4 %&gt;% filter(!(region_code %in% c("11","27","44")))
```

```
## # A tibble: 3,909 × 13
##    region_code region_nom dep_code dep_nom           elu_nom    elu_prenom sexe 
##    &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;             &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;
##  1 01          Ain        0101     Ambérieu-En-Bugey BRUNET     Joël       M    
##  2 01          Ain        0101     Ambérieu-En-Bugey PETIT      Aurélie    F    
##  3 01          Ain        0102     Attignat          FOURNIER   Clotilde   F    
##  4 01          Ain        0102     Attignat          MARTIN     Walter     M    
##  5 01          Ain        0103     Valserhône        LARMANJAT  Guy        M    
##  6 01          Ain        0103     Valserhône        OLLIET     Anne-Laure F    
##  7 01          Ain        0104     Belley            BOREL      Aurélie    F    
##  8 01          Ain        0104     Belley            HEDON      Jean-Yves  M    
##  9 01          Ain        0105     Bourg-En-Bresse-1 BERTRAND-… Hélène     F    
## 10 01          Ain        0105     Bourg-En-Bresse-1 MORAND     Alexis     M    
## # ℹ 3,899 more rows
## # ℹ 6 more variables: date_naissance &lt;chr&gt;, profession_code &lt;dbl&gt;,
## #   profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;, fonction &lt;chr&gt;,
## #   fonction_date &lt;chr&gt;
```


---

### Exercice de filtre

Je vous demande de filtrer rne4 pour ne conserver que les élu·es dont le prénom comporte moins de 5 lettres.

--


```r
rne4 %&gt;% filter(nchar(elu_prenom) &lt; 5)
```

```
## # A tibble: 283 × 13
##    region_code region_nom dep_code dep_nom              elu_nom elu_prenom sexe 
##    &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;                &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;
##  1 01          Ain        0101     Ambérieu-En-Bugey    BRUNET  Joël       M    
##  2 01          Ain        0103     Valserhône           LARMAN… Guy        M    
##  3 01          Ain        0114     Nantua               DEGUER… Jean       M    
##  4 01          Ain        0117     Replonges            BILLOU… Guy        M    
##  5 01          Ain        0121     Trévoux              PÉCHOUX Marc       M    
##  6 02          Aisne      0201     Bohain-En-Vermandois ROJO    Yann       M    
##  7 02          Aisne      0204     Essômes-Sur-Marne    MARICOT Anne       F    
##  8 02          Aisne      0206     Villeneuve-sur-Aisne MOUGEN… Paul       M    
##  9 03          Allier     0303     Commentry            SAINT-… Anne       F    
## 10 03          Allier     0309     Montluçon-1          MALBET  Marc       M    
## # ℹ 273 more rows
## # ℹ 6 more variables: date_naissance &lt;chr&gt;, profession_code &lt;dbl&gt;,
## #   profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;, fonction &lt;chr&gt;,
## #   fonction_date &lt;chr&gt;
```


---

## select() : pour choisir ses variables

La fonction `select()`de `{dplyr}` permet de sélectionner les variables jugées utiles ou pertinentes.

Cela comporte deux intérêts principaux :
1. alléger votre jeu de données pour rendre les opérations plus rapides ;
2. simplifier la lecture de votre jeu de données.

La manière la plus simple d'utiliser `select()`consiste à lister les variables retenues par leur nom :


```r
rne4 %&gt;% select(elu_nom, elu_prenom, sexe)
```

```
## # A tibble: 4,055 × 3
##    elu_nom           elu_prenom sexe 
##    &lt;chr&gt;             &lt;chr&gt;      &lt;chr&gt;
##  1 BRUNET            Joël       M    
##  2 PETIT             Aurélie    F    
##  3 FOURNIER          Clotilde   F    
##  4 MARTIN            Walter     M    
##  5 LARMANJAT         Guy        M    
##  6 OLLIET            Anne-Laure F    
##  7 BOREL             Aurélie    F    
##  8 HEDON             Jean-Yves  M    
##  9 BERTRAND-MARÉCHAL Hélène     F    
## 10 MORAND            Alexis     M    
## # ℹ 4,045 more rows
```


---

### De multiples façons de sélectionner

La fonction `select()` offre d'autres possibilités de sélection :
* **par index** en indiquant le rang des variables retenues ;
* **par un vecteur** soit en listant les noms des variables comme chaînes de caractères, soit par index.




```r
rne4 %&gt;% select(1:5) %&gt;% head() # affichera les 5 premières variables
```

```
## # A tibble: 6 × 5
##   region_code region_nom dep_code dep_nom           elu_nom  
##   &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;             &lt;chr&gt;    
## 1 01          Ain        0101     Ambérieu-En-Bugey BRUNET   
## 2 01          Ain        0101     Ambérieu-En-Bugey PETIT    
## 3 01          Ain        0102     Attignat          FOURNIER 
## 4 01          Ain        0102     Attignat          MARTIN   
## 5 01          Ain        0103     Valserhône        LARMANJAT
## 6 01          Ain        0103     Valserhône        OLLIET
```

```r
rne4 %&gt;% select(c("elu_nom","elu_prenom","region_nom")) %&gt;% head()
```

```
## # A tibble: 6 × 3
##   elu_nom   elu_prenom region_nom
##   &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;     
## 1 BRUNET    Joël       Ain       
## 2 PETIT     Aurélie    Ain       
## 3 FOURNIER  Clotilde   Ain       
## 4 MARTIN    Walter     Ain       
## 5 LARMANJAT Guy        Ain       
## 6 OLLIET    Anne-Laure Ain
```


---

### Les helpers

Le "verbe" `select()` (suivant la nomenclature du `{tidyverse}`) propose également des **[helpers functions](https://www.rdocumentation.org/packages/dplyr/versions/0.7.2/topics/select_helpers)** (abrégées *helpers*) qui permettent de réaliser des sélections plus fines, notamment en utilisant des expressions régulières.

Par exemple, le helper `starts_with()` permet de soumettre une chaîne de caractères qui doit figurer au début du nom de la variable pour qu'elle soit retenue :


```r
rne4 %&gt;% select(starts_with("elu"), date_naissance) %&gt;% head()
```

```
## # A tibble: 6 × 3
##   elu_nom   elu_prenom date_naissance
##   &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;         
## 1 BRUNET    Joël       02/05/1955    
## 2 PETIT     Aurélie    29/08/1982    
## 3 FOURNIER  Clotilde   01/09/1966    
## 4 MARTIN    Walter     07/05/1966    
## 5 LARMANJAT Guy        28/09/1962    
## 6 OLLIET    Anne-Laure 15/03/1969
```

---

### Aparté : les regex



---

## mutate() : pour créer ou modifier ses variables

La fonction `mutate()` permet de modifier ou créer des variables. Elle appelle le nom de la variable créé et l'opération nécessaire pour la renseigner. Si le nom est le même qu'une variable existante, cette dernière la remplacera.

Pour le jeu de données `rne4`, nous pouvons par exemple convertir la variable `date_naissance` en date (ce qui peut s'avérer utile).

Pour cela, nous utiliserons la fonction `as.Date()` de `{rbase}` qui convertit une chaîne de caractères en date :


```r
rne4 %&gt;% mutate(date_naissance = as.Date(date_naissance,
                                         format = "%d/%m/%Y")) %&gt;% head()
```

```
## # A tibble: 6 × 13
##   region_code region_nom dep_code dep_nom           elu_nom   elu_prenom sexe 
##   &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;             &lt;chr&gt;     &lt;chr&gt;      &lt;chr&gt;
## 1 01          Ain        0101     Ambérieu-En-Bugey BRUNET    Joël       M    
## 2 01          Ain        0101     Ambérieu-En-Bugey PETIT     Aurélie    F    
## 3 01          Ain        0102     Attignat          FOURNIER  Clotilde   F    
## 4 01          Ain        0102     Attignat          MARTIN    Walter     M    
## 5 01          Ain        0103     Valserhône        LARMANJAT Guy        M    
## 6 01          Ain        0103     Valserhône        OLLIET    Anne-Laure F    
## # ℹ 6 more variables: date_naissance &lt;date&gt;, profession_code &lt;dbl&gt;,
## #   profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;, fonction &lt;chr&gt;,
## #   fonction_date &lt;chr&gt;
```

---

### Création de plusieurs variables

Il est possible de créer plusieurs variables d'un seul appel de `mutate()`. Il suffit de séparer les opérations par des virgules.

Les variables sont créées dans l'ordre où elles sont listées dans la fonction. Il est donc possible de créer des variables *"en cascade"*. Nous pouvons par exemple utiliser la fonction `year()` de la librairie `{lubridate}` pour extraire l'année sous forme de double :


```r
library(lubridate)

rne4 %&gt;% mutate(date_naissance = as.Date(date_naissance,
                                         format = "%d/%m/%Y"),
                annee_naissance = year(date_naissance)) %&gt;%
  select(date_naissance, annee_naissance) %&gt;% 
  head()
```

```
## # A tibble: 6 × 2
##   date_naissance annee_naissance
##   &lt;date&gt;                   &lt;dbl&gt;
## 1 1955-05-02                1955
## 2 1982-08-29                1982
## 3 1966-09-01                1966
## 4 1966-05-07                1966
## 5 1962-09-28                1962
## 6 1969-03-15                1969
```


---

### Exemple de calcul complexe pour une variable

La création d'une variable peut parfois nécessité plusieurs opérations pour arriver à un résultat satisfaisant.

Par exemple, ici, **calculer l'âge** d'un·e élu·e nécessite plusieurs étapes :
1. convertir la variable `date_naissance` au bon format ;
2. récupérer la date du jour avec la fonction `today()` ;
3. calculer la différence entre la `date_naissance` et `today()` avec la fonction `difftime()` ;
4. le grain minimum étant la semaine (paramétré avec l'argument `units = "weeks"`), nous devrons diviser le résultat par 52.25 (nombre de semaine d'une année calendaire) ;
5. mais avant cela, il nous faudra convertir la sortie de `difftime()` en double avec `as.numeric()`.

---

En pratique, voilà ce que ça donne :


```r
rne4 %&gt;% mutate(date_naissance = as.Date(date_naissance, format = "%d/%m/%Y"),
                age = as.numeric(difftime(today(), date_naissance, units = "weeks"))/52.25) %&gt;% 
  select(date_naissance, age)
```

```
## # A tibble: 4,055 × 2
##    date_naissance   age
##    &lt;date&gt;         &lt;dbl&gt;
##  1 1955-05-02      68.5
##  2 1982-08-29      41.2
##  3 1966-09-01      57.2
##  4 1966-05-07      57.5
##  5 1962-09-28      61.1
##  6 1969-03-15      54.7
##  7 1979-08-07      44.3
##  8 1962-12-22      60.9
##  9 1974-09-10      49.2
## 10 1987-08-04      36.3
## # ℹ 4,045 more rows
```

--

... et encore, on obtient un format double avec des décimales ! Pour le corriger, il faudra encapsuler le résultat dans la fonction `round()` en renseignant l'argument `digits = 0`.

---

### Exercice à vous !

Je vous demande de nettoyer cette base de la manière suivante :
1. ne retenez que les variables de nom et code des régions, nom et prénom des élu·es, sexe, date de naissance et date de début de mandat ;
2. renommez-les de la même manière que moi : "region_code", "dep_code", "elu_nom", "elu_prenom", "sexe", "date_naissance" ;
3. calculer une variable "age" pour chaque élu arrondit à 1 décimales ;
4. stocker le résultat dans une nouvelle variable : `rne4_c` pour rne4 compact.

--


```r
rne4_c &lt;- read_csv("https://www.data.gouv.fr/fr/datasets/r/430e13f9-834b-4411-a1a8-da0b4b6e715c") %&gt;%
  setNames(c("region_code","region_nom","dep_code","dep_nom","elu_nom","elu_prenom",
                   "sexe","date_naissance","profession_code","profession_nom","date_mandat",
                   "fonction","fonction_date")) %&gt;% 
  dplyr::select(region_code, region_nom, elu_nom, elu_prenom, sexe, date_naissance, date_mandat) %&gt;%
  mutate(date_naissance = as.Date(date_naissance, format = "%d/%m/%Y"),
         age = round(as.numeric(difftime(today(), date_naissance, units = "weeks"))/52.25, digits = 1))
```


---

background-image: url("https://media.giphy.com/media/xB2DKVtgNiJzZtAYht/giphy.gif")
class: center, top, inverse

# 3. Produire des synthèses

---

## Grouper et synthétiser

Les jeux de données s'avèrent généralement trop vastes pour pouvoir être analysés bruts. Qu'il s'agisse de chercher des pistes de sujet ou de réaliser des visualisations, vous aurez besoin de produire des synthèses se concentrant sur un aspect particulier du jeu de données.

Pour cela, la librairie `{dplyr}` propose deux fonctions complémentaires permettant de réaliser des *"synthèses groupées"* :
* `group_by()` qui permet de grouper les observations par les différentes valeurs d'une ou plusieurs variables ;
* `summarise()` qui permet de générer une variable calculée sur la base des groupes ainsi constitués.

---

### group_by()

Seule, la fonction `group_by()` ne "produit" rien. Elle laisse tout juste apparaître les groupes constitués suivant la liste de variable fournie.


```r
rne4_c %&gt;% group_by(sexe)
```

```
## # A tibble: 1,753 × 8
## # Groups:   sexe [2]
##    region_code region_nom elu_nom    elu_prenom sexe  date_naissance date_mandat
##    &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;         &lt;chr&gt;      
##  1 01          Guadeloupe ARMOUGOM   Betty Vér… F     1965-07-09     02/07/2021 
##  2 01          Guadeloupe BAILLET    Patricia   F     1970-06-17     02/07/2021 
##  3 01          Guadeloupe BARDAIL    Jean       M     1951-05-30     02/07/2021 
##  4 01          Guadeloupe BITUFWILA  Aurélie    F     1991-08-21     02/07/2021 
##  5 01          Guadeloupe BONDOT-GA… Gersiane   F     1963-02-09     02/07/2021 
##  6 01          Guadeloupe BOREL-LIN… Josette    F     1941-08-12     02/07/2021 
##  7 01          Guadeloupe BRUDEY     Hilaire    M     1960-03-27     02/07/2021 
##  8 01          Guadeloupe CHALUS     Ary        M     1961-12-06     02/07/2021 
##  9 01          Guadeloupe CHAMMOUGO… Sylvie     F     1972-07-23     02/07/2021 
## 10 01          Guadeloupe CHATEAUBON Eddy       M     1971-07-01     02/07/2021 
## # ℹ 1,743 more rows
## # ℹ 1 more variable: age &lt;dbl&gt;
```


---

### summarise()

La fonction `summarise()` permet de générer de nouvelles variables, à la manière de `mutate()`, avec deux différences notables :

1. elle le fait sur la base des groupes constitués avec `group_by()`
2. elle écarte toutes les autres variables.

Si nous groupons comme à la slide précédente le jeu de données par sexe, il nous est possible de calculer l'âge moyen *"par sexe"* en utilisant la fonction `summarise()` en aval de `group_by(sexe)` :

--


```r
rne4_c %&gt;% group_by(sexe) %&gt;% summarise(age_moyen = mean(age))
```

```
## # A tibble: 2 × 2
##   sexe  age_moyen
##   &lt;chr&gt;     &lt;dbl&gt;
## 1 F          52.5
## 2 M          54.3
```

Je souligne ici l'expression *"calculer par sexe"* car elle me semble bien résumer la façon dont fonctionne le *grouping*.

---

### Multigrouping

Il est possible de passer plus d'un nom de variable à `group_by()`. `summarise()` procédera alors par un calcul sur chacun des groupes croisés, c'est-à-dire toutes les combinaisons possibles des valeurs de chaque variable.

Nous pouvons ainsi complexifier notre synthèse sur les âges moyens par sexe en y ajoutant le critère de la région :


```r
rne4_c %&gt;% group_by(region_nom, sexe) %&gt;%
  summarise(age_moyen = mean(age))
```

```
## # A tibble: 28 × 3
## # Groups:   region_nom [14]
##    region_nom              sexe  age_moyen
##    &lt;chr&gt;                   &lt;chr&gt;     &lt;dbl&gt;
##  1 Auvergne-Rhône-Alpes    F          53.0
##  2 Auvergne-Rhône-Alpes    M          53.6
##  3 Bourgogne-Franche-Comté F          54.3
##  4 Bourgogne-Franche-Comté M          57.4
##  5 Bretagne                F          52.5
##  6 Bretagne                M          53.0
##  7 Centre-Val De Loire     F          51.3
##  8 Centre-Val De Loire     M          54.0
##  9 Grand Est               F          51.7
## 10 Grand Est               M          55.2
## # ℹ 18 more rows
```


---

### count() 1/2

Il peut être tentant d'utiliser la synthèse groupée pour calculer le nombre d'élément par groupe avec la fonction `n()`. Si nous voulions calculer le nombre d'homme et de femme par région, nous pourrions procéder ainsi  :

```r
rne4 %&gt;% group_by(region_nom, sexe) %&gt;% summarise(n = n())
```

```
## # A tibble: 190 × 3
## # Groups:   region_nom [95]
##    region_nom              sexe      n
##    &lt;chr&gt;                   &lt;chr&gt; &lt;int&gt;
##  1 Ain                     F        24
##  2 Ain                     M        23
##  3 Aisne                   F        21
##  4 Aisne                   M        21
##  5 Allier                  F        19
##  6 Allier                  M        19
##  7 Alpes-De-Haute-Provence F        15
##  8 Alpes-De-Haute-Provence M        15
##  9 Alpes-Maritimes         F        27
## 10 Alpes-Maritimes         M        27
## # ℹ 180 more rows
```

---

### count() 2/2

Une façon beaucoup plus simple et directe de le faire consiste à appeler la fonction `count()` en spécifiant pour argument les variables par lesquelles on souhaite grouper :


```r
rne4 %&gt;% count(region_nom, sexe)
```

```
## # A tibble: 190 × 3
##    region_nom              sexe      n
##    &lt;chr&gt;                   &lt;chr&gt; &lt;int&gt;
##  1 Ain                     F        24
##  2 Ain                     M        23
##  3 Aisne                   F        21
##  4 Aisne                   M        21
##  5 Allier                  F        19
##  6 Allier                  M        19
##  7 Alpes-De-Haute-Provence F        15
##  8 Alpes-De-Haute-Provence M        15
##  9 Alpes-Maritimes         F        27
## 10 Alpes-Maritimes         M        27
## # ℹ 180 more rows
```

---

### arrange()

Une fois certains calculs réalisés, il peut être intéressant d'ordonner les résultats suivant une variable pour trouver les valeurs les plus ou moins élevées.

La fonction `arrange()` permet de réaliser cette opération suivant deux modalités :
* `arrange(variable)` : triera par ordre croissant les valeurs de la variable passée en argument ;
* `arrange(desc(variable))` : triera par ordre décroissant les valeurs de la variable passée en argument ;
* `arrange(variable1, variable2)` : triera d'abord par la variable1 puis par la variable2 (en cas de valeurs égales dans variables1).

---

#### Exemple : arrange()

Nous pouvons ainsi voir où la moyenne d'âge des conseillers régionaux est la plus basse en quelques opératons :


```r
rne4_c %&gt;% 
  group_by(region_nom, sexe) %&gt;%
  summarise(age_moyen = mean(age)) %&gt;% 
  filter(sexe == "M") %&gt;% 
  arrange(age_moyen)
```

```
## # A tibble: 14 × 3
## # Groups:   region_nom [14]
##    region_nom                 sexe  age_moyen
##    &lt;chr&gt;                      &lt;chr&gt;     &lt;dbl&gt;
##  1 Île-De-France              M          51.4
##  2 Hauts-De-France            M          52.4
##  3 Bretagne                   M          53.0
##  4 Normandie                  M          53.3
##  5 Auvergne-Rhône-Alpes       M          53.6
##  6 Occitanie                  M          53.9
##  7 Centre-Val De Loire        M          54.0
##  8 Nouvelle-Aquitaine         M          54.3
##  9 Pays De La Loire           M          54.6
## 10 Grand Est                  M          55.2
## 11 Bourgogne-Franche-Comté    M          57.4
## 12 Provence-Alpes-Cote D'Azur M          58.4
## 13 La Réunion                 M          58.6
## 14 Guadeloupe                 M          58.8
```

---

### WARNING : pensez à dégrouper !

L'opération `group_by()` semble "indolore" mais elle modifie en fait les métadonnées d'un jeu de données. Il est recommandé de *"dégrouper"* après avoir réalisé votre synthèse pour éviter de rencontrer des erreurs.

La fonction `ungroup()` permet de supprimer les groupings dans un jeu de données. La seule indication dont vous disposerez cependant, c'est l'absence de l'annonce des *"groups"* en tête de la sortie de votre pipeline :


```r
rne4_c %&gt;% 
  group_by(region_nom, sexe) %&gt;%
  summarise(age_moyen = mean(age)) %&gt;% 
  filter(sexe == "M") %&gt;% 
  arrange(age_moyen) %&gt;% 
  ungroup()
```

```
## # A tibble: 14 × 3
##    region_nom                 sexe  age_moyen
##    &lt;chr&gt;                      &lt;chr&gt;     &lt;dbl&gt;
##  1 Île-De-France              M          51.4
##  2 Hauts-De-France            M          52.4
##  3 Bretagne                   M          53.0
##  4 Normandie                  M          53.3
##  5 Auvergne-Rhône-Alpes       M          53.6
##  6 Occitanie                  M          53.9
##  7 Centre-Val De Loire        M          54.0
##  8 Nouvelle-Aquitaine         M          54.3
##  9 Pays De La Loire           M          54.6
## 10 Grand Est                  M          55.2
## 11 Bourgogne-Franche-Comté    M          57.4
## 12 Provence-Alpes-Cote D'Azur M          58.4
## 13 La Réunion                 M          58.6
## 14 Guadeloupe                 M          58.8
```


---

background-image: url("https://media.giphy.com/media/yjI5G3pE3NH3O/giphy.gif")
class: center, top, inverse

# 4. Une grammaire pour les graphs





---

## Aux origines de {ggplot2}

.pull-left[
Le package `{ggplot2}` repose sur l'article [A layered grammar of graphics](https://vita.had.co.nz/papers/layered-grammar.html), publié en 2010 par Hadley Wickham (créateur du {tidyverse}). Cette publication se veut une version améliorée et open source du Grammar of graphics, publié en 2006 par Leland Wilkinson.

Ces deux études poursuivaient le même but : formaliser la production des graphs comme une série d'opérations simples.
]

.pull-right[
![](./img/wilkinson_vs_wickham.png)


Extrait de A layered grammar of graphics, Wickham, 2010.
]

---

## Une construction "par couche"

.pull-left[
![](./img/layered_grammar_graphics.png)
]

.pull-right[
1. les **data** ;
2. les **aesthetics** : correspondance entre données et dimensions du graphique (axes, couleurs, formes, etc.) ;
3. les **échelles** ;
4. les **geoms** : objets géométriques représentants les points de données (points, lignes, barres, cercles, etc.) ;
5. les **statistics** : indications statistiques dans la dataviz ;
6. les **facets** : sous-graphs 
7. le **système de coordonnées** : cartésien ou polaire ? (nous verrons à quoi ça sert)

]

---

### Les principales composantes de la Grammar of Graphics

![](./img/gg_components.png)

---

### La "grammar of graphics" en pratique

`{ggplot2}` se veut une traduction opérationnelle des concepts de la *layered grammar of graphics*.

En pratique, il suffit pour produire un graph avec cette librairie d'un minimum de trois éléments (**data**, **geom** et **aesthetics**).



```r
ggplot(data = &lt;DATA&gt;) + 
  &lt;GEOM_FUNCTION&gt;(aes(&lt;MAPPINGS&gt;))
```


#### mapping
Dans le schéma ci-dessus, `mappings` se réfère au fait d'associer une dimension du jeu de données à une dimension esthétique de la dataviz.

En informatique, on parle de *"mappage"* et de *"mapper"* pour décrire l'association de deux données d'ensembles différents.

---

#### Exemple : cigares et cigarillos

Jetons un oeil rapide à la liste des produits vendus sous l'étiquette tabac autre que les cigarettes avec la base [Produits du tabac et produits connexes déclarés sur le marché français](https://www.data.gouv.fr/fr/datasets/produits-du-tabac-et-produits-connexes-declares-sur-le-marche-francais), publiée par l'Anses sur data.gouv.fr :


```r
cigares &lt;- read_csv2("https://www.data.gouv.fr/fr/datasets/r/2e50e0a2-e81e-45bb-9fe9-3f8a1c835e57") %&gt;% 
  mutate(Longueur_Produit = as.double(Longueur_Produit),
         Diamètre_Produit = as.double(Diamètre_Produit))

cigares %&gt;% ggplot() +
  geom_point(aes(x = Longueur_Produit, y = Diamètre_Produit,
                 color = Type_Produit))
```

![](index_files/figure-html/exemple_gg_cigares&amp;co-1.png)&lt;!-- --&gt;


---

### Les aesthetics disponibles

Outre les deux axes, `x` et `y`, `{ggplot2}` donne accès à toutes les dimensions visuelles du graph via les aesthetics :
* `color` : pour la couleur des points ;
* `fill` : pour le remplissage ;
* `alpha` : pour l'opacité ;
* `size`: la taille ;
* `shape` : pour la forme ;
* `stroke` : la continuité d'un trait.


---

### Les aesthetics non mappées

Les dimensions ne sont pas obligatoirement mappée à une variable. Elles peuvent aussi se voir attribuer une valeur arbitraire. Pour cela, il suffit de les renseigner en dehors de l'objet `aes()`. Par exemple :


```r
cigares %&gt;% ggplot() +
  geom_point(aes(x = Longueur_Produit, y = Diamètre_Produit,
                 color = Type_Produit), alpha = 0.3, size = 0.5)
```

![](index_files/figure-html/aes_non_mappees-1.png)&lt;!-- --&gt;


---

background-image: url("https://media.giphy.com/media/kcCkg4ao1PTCQiMkpC/giphy.gif")
class: center, top, inverse

# 5. Les `geoms` de {ggplot}

---

## A chaque `geom` son usage

Chaque `geometry` disponible dans `{ggplot2}` permet de traiter certains types de données et pas d'autres. Nous distinguerons notamment trois grandes catégories :
1. **les variables catégorielles** : c'est-à-dire les variables qui distinguent un nombre limité de valeurs se rapportant à des groupes Elles peuvent être :
  * **ordonnées** ;
  * **non ordonnées**.
2. **les variables discrètes** : c'est-à-dire les variables numériques dont les valeurs sont en nombre limité sur une échelle ;
3. **les variables continues** : c'est-à-dire les variables dont les valeurs numériques peuvent prendre un nombre infini de valeur sur une échelle continue (c'est aussi le cas des heures et dates)

---

## Fonctionnement générique des `geom`

Les `geometry` sont ajoutées juste après les données par couche.

Leur forme générique est toujours : `geom_*` où `*` désigne la forme géométrique ajoutée.

Les arguments sont énumérés :
* dans un objet `aes()` quand ils sont mappés à une variable ;
* dans la parenthèse quand on souhaite leur assigner une valeur fixe.

Outre les `aesthetics` évoquées plus haut, deux arguments peuvent être utiles :
* `na.rm` : permet de rendre silencieuse la suppression des NAs ;
* `position` : permet de spécifier la position des éléments géométriques entre eux (notamment `geom_col()`).


---

### Que peut-on faire avec un jeu de données ?

Penchons-nous sur les [indicateurs de suivi de l’épidémie de COVID-19](https://www.data.gouv.fr/fr/datasets/indicateurs-de-suivi-de-lepidemie-de-covid-19/) publiés quotidiennement par le Ministère de la Santé.




```r
covid &lt;- read_csv("https://www.data.gouv.fr/fr/datasets/r/381a9472-ce83-407d-9a64-1b8c23af83df")

head(covid)
```

```
## # A tibble: 6 × 5
##   extract_date tx_incid     R taux_occupation_sae tx_pos
##   &lt;date&gt;          &lt;dbl&gt; &lt;dbl&gt;               &lt;dbl&gt;  &lt;dbl&gt;
## 1 2020-03-18      NA       NA                15.2     NA
## 2 2020-03-19       5.57    NA                19.8     NA
## 3 2020-03-20       8.40    NA                25.6     NA
## 4 2020-03-21      11.0     NA                28.7     NA
## 5 2020-03-22      13.6     NA                33.1     NA
## 6 2020-03-23      18.3     NA                41.1     NA
```


---

### geom_line

`geom_line` trace une ligne entre chaque point de données.

Dans l'imaginaire collectif, il invoque deux notions :
* la continuité dans le temps (suivant l'axe des x) ;
* la continuité d'un phénomène.


```r
covid %&gt;% ggplot(aes(x = extract_date)) +
  geom_line(aes(y = tx_incid), color = "blue") +
  geom_line(aes(y = taux_occupation_sae), linetype = "longdash", color = "red")
```

![](index_files/figure-html/covid_geom_line-1.png)&lt;!-- --&gt;

---

### geom_point

`geom_point` trace un point par croisement entre deux coordonnées sur les axes `x` et `y`.

A ce titre, il permet d'étudier la relation entre deux variables (donc deux dimensions d'un même phénomène).

Prenons le jeu de données "cigarettes" pour regarder la relation entre les émissions de goudron et de nicotine :


```r
cigarettes &lt;- read_csv2("https://www.data.gouv.fr/fr/datasets/r/782aeeef-b2d3-4781-b0bf-a23f72a1c798")

glimpse(cigarettes)
```

```
## Rows: 3,646
## Columns: 25
## $ Marché_National_Produit                 &lt;chr&gt; "FR", "FR", "FR", "FR", "FR", …
## $ Catégorie_Produit                       &lt;chr&gt; "Produit du tabac", "Produit d…
## $ Type_Produit                            &lt;chr&gt; "Cigarette", "Cigarette", "Cig…
## $ Code_Référence                          &lt;chr&gt; "1637 ORIGINE [4A27B949A67924C…
## $ Date_Dernière_Mise_A_Jour_Du_Dossier    &lt;chr&gt; "02/02/2023 15:37:00", "02/02/…
## $ Nom_Marque_Produit                      &lt;chr&gt; "1637", "1637", "Alluvé", "All…
## $ `Nom_Sous-type_Marque_Produit`          &lt;chr&gt; "Origine", "Rouge", "tabac", "…
## $ Filtre_Produit                          &lt;chr&gt; "filtre", "filtre", "filtre", …
## $ Unités_Conditionnement_Produit          &lt;dbl&gt; 2000, 2000, 4000, 4000, 2000, …
## $ Type_Conditionnement_Produit            &lt;chr&gt; "Boîte à couvercle supérieur r…
## $ Type_Numéro_Produit                     &lt;chr&gt; "EAN", "EAN", "GTIN", "GTIN", …
## $ Numéro_Produit                          &lt;chr&gt; "3258170830010", "370107824371…
## $ Date_Notification                       &lt;chr&gt; "5/9/2019 08:14:00", "4/1/2022…
## $ Date_Lancement_Produit                  &lt;chr&gt; "9/9/2019 00:00:00", "1/7/2022…
## $ Longueur_Produit                        &lt;dbl&gt; 8400, 8400, 10000, 10000, 8300…
## $ Diamètre_Produit                        &lt;dbl&gt; 782, 780, 540, 540, 778, 778, …
## $ Poids_Produit                           &lt;dbl&gt; 83000, 85000, 57000, 56000, 99…
## $ Poids_Tabac_Produit                     &lt;chr&gt; "580.00", "600.00", "410.00", …
## $ Longueur_Filtre_Produit                 &lt;chr&gt; "27.00", "27.00", "30.00", "30…
## $ Ventilation_Filtre_Cigarette            &lt;chr&gt; "15.00", "30.00", "30.00", "65…
## $ Baisse_Pression_Filtre_Cigarette_Fermé  &lt;dbl&gt; 13500, 13000, 21000, 27000, 16…
## $ Baisse_Pression_Filtre_Cigarette_Ouvert &lt;dbl&gt; 12000, 10000, 14000, 12000, 11…
## $ Émission_Goudron                        &lt;dbl&gt; 822, 900, 600, 300, 900, 500, …
## $ Émission_Nicotine                       &lt;chr&gt; "0.56", "0.89", "0.69", "0.30"…
## $ Émission_CO                             &lt;dbl&gt; 992, 900, 500, 200, 800, 500, …
```

---

#### Exemple de graph


```r
cigarettes %&gt;%
  mutate(Émission_Nicotine = as.double(Émission_Nicotine)) %&gt;% 
  ggplot() +
  geom_point(aes(x = Émission_Goudron, y = Émission_Nicotine))
```

![](index_files/figure-html/cigarette_point-1.png)&lt;!-- --&gt;


---

#### Attention à l'overplotting !


```r
cigarettes %&gt;% mutate(Émission_Nicotine = as.double(Émission_Nicotine)) %&gt;% 
  ggplot() +
  geom_point(aes(x = Émission_Goudron, y = Émission_Nicotine, color =  Nom_Marque_Produit))
```

![](index_files/figure-html/overplotting_geom_point-1.png)&lt;!-- --&gt;



---

#### Exemple de "tous les graphs ne marchent pas avec toutes les données"



```r
covid %&gt;% ggplot() +
  geom_point(aes(x = taux_occupation_sae, y = tx_incid, color = extract_date))
```

![](index_files/figure-html/covid_geom_point-1.png)&lt;!-- --&gt;

---

### geom_bar

Le `geom_bar` trace un graphique de distribution sur une seule dimension. Autrement dit, il calcule d'abord le nombre d'observation par tranches de valeur pour la variable mappée sur `x`. En clair, il visualise un `count()`.

#### Histogramme

Quand on mappe `x` sur une variable continue, il produit un histogramme (dont l'échelle et les fourchettes sont calculées de manière automatique) :


```r
cigarettes %&gt;% mutate(Émission_Nicotine = as.double(Émission_Nicotine)) %&gt;% 
  ggplot() +
  geom_bar(aes(x = Émission_Goudron))
```

![](index_files/figure-html/geom_bar_histogramme-1.png)&lt;!-- --&gt;


---

#### Graphique en barre

`geom_bar` peut également mapper une variable catégorielle. Dans ce cas, la fonction tracera une colonne par valeur de la variable. Dans ce cas, on ne parle pas d'histogramme mais de graphique de distribution en colonne :


```r
cigares %&gt;% ggplot() +
  geom_bar(aes(x = Type_Produit))
```

![](index_files/figure-html/geom_bar_distrib-1.png)&lt;!-- --&gt;


---

### geom_col

La fonction `geom_col` trace une colonne par valeur d'une variable catégorielle passée en `x` dont la hauteur dépend de la variable mappée en `y`. Elle attend donc une variable continue sur l'axe des `y` :


```r
cigares %&gt;% 
  group_by(Type_Produit) %&gt;%
  summarise(poids_moyen = mean(Poids_Produit)/1000) %&gt;% 
  ggplot() +
  geom_col(aes(x = Type_Produit, y = poids_moyen))
```

![](index_files/figure-html/geom_col-1.png)&lt;!-- --&gt;


---



background-image: url("https://media.giphy.com/media/RmfzOLuCJTApa/giphy.gif")
class: center, top

#### Et encore beaucoup d'autres avec leurs options que vous pourrez découvrir en fouinant du côté de la doc.

.footnote[Et notamment du [site officiel de ggplot](https://ggplot2.tidyverse.org/).]

---


background-image: url("https://media.giphy.com/media/js0dt5JLCU01bvlt7d/giphy.gif")
class: center, top, inverse

# 6. Rendons tout ça un peu plus joli

---

### Aparté : stocker un graph

Comme tout ce que ous manipulez dans `R`, les graphiques générés par les fonctions de `{ggplot2}` sont des objets. Ils peuvent donc être stockés dans des variables :


```r
cigares_gpoint &lt;- cigares %&gt;% ggplot() +
  geom_point(aes(x = Longueur_Produit, y = Diamètre_Produit,
                 color = Type_Produit))

cigares_gpoint
```

![](index_files/figure-html/stocker_graph-1.png)&lt;!-- --&gt;

---

### Un peu de couleur !

Vous pouvez manipuler les couleurs de plusieurs manières.

Si le mapping permet de faire correspondre un code couleur à une valeur, de nombreuses options et librairies vous permettent de choisir des échelles de couleur précalculées ou à paramétrer.

---

#### Viridis

Une des librairies les plus célèbres est `{viridis}`, qui propose plusieurs type d'échelles suivant les besoins (continues, catégorielles, adaptées aux diverses formes de daltonisme...).

Plus de détails et d'exemples dans [la page d'introduction à ce package](https://cran.r-project.org/web/packages/viridis/vignettes/intro-to-viridis.html).


```r
library(viridis)

cigares_gpoint + scale_color_viridis(discrete = TRUE)
```

![](index_files/figure-html/ggplot_viridis-1.png)&lt;!-- --&gt;


---

#### `{RColorBrewer}`


```r
library(RColorBrewer)

cigares_gpoint + scale_colour_brewer(palette = "Set1")
```

![](index_files/figure-html/color_brewer-1.png)&lt;!-- --&gt;

---

### `theme()` : objet à tout paramétrer

L'objet `theme()` permet de régler la majorité des aspects visuels non mappés de vos graphs : fonds, axes, textes, "ticks", titres et sous-titres, etc.

Les arguments de `theme()` doivent être paramétrés selon leur type :
* `element_line()` ;
* `element_text()` ;
* `element_rect()`, etc.
* `element_blank()` quand vous voulez les supprimer.

---

#### `theme()` : exemple


```r
cigares_gpoint +
  labs(title = "Rapport longueur ~ diamètre des produits du tabac autres que les cigarettes") +
  theme(
  legend.position = "none",
  panel.grid.major = element_line(colour = "grey50"),
  plot.background = element_rect(fill = "grey")
)
```

![](index_files/figure-html/ggplot_theme-1.png)&lt;!-- --&gt;



---

background-image: url("https://media.giphy.com/media/l378BzHA5FwWFXVSg/giphy.gif")
class: center, top, inverse

# 7. Démultiplions nos graphs avec les facets

---

## `facet_*`

Les fonctions de `facet` vous permette de créer un graph par valeur de la variable choisie, suivant les paramètres définis en amont.

En pratique, cela permet d'observer l'effet d'une variable sur votre graph.

Il existe deux fonctions principales :
* `facet_wrap()` qui prend une seule variable en facet et va organiser les graphs en lignes et colonnes ;
* `facet_grid()` qui prend une ou deux variables en facet et les dispose en ligne et colonne suivant l'ordre où elles sont appelées.

---

### `facet_wrap()`


```r
cigarettes %&gt;%
  mutate(Émission_Nicotine = as.double(Émission_Nicotine)) %&gt;% 
  ggplot() +
  geom_point(aes(x = Émission_Goudron, y = Émission_Nicotine)) +
  facet_wrap( ~ Filtre_Produit)
```

![](index_files/figure-html/cigarettes_facet_filtres-1.png)&lt;!-- --&gt;

---
class: inverse, center, middle

# Merci !


Contact : [sylvainlapoix@gmail.com](mailto:sylvainlapoix@gmail.com)


    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
