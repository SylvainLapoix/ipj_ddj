<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>IPJ - Datajournalisme</title>
    <meta charset="utf-8" />
    <meta name="author" content="Sylvain Lapoix" />
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# IPJ - Datajournalisme
## Cours 3 : Nettoyer et manipuler des données en R
### Sylvain Lapoix
### 23/11/2020

---


background-image: url("https://media.giphy.com/media/fCUCbWXe9JONVsJSUd/giphy.gif")
class: center, top, inverse

# 1. Correction de l'exercice




---

### Méthodologie

.pull-left[#### Rappel des consignes

Je vous avais demandé avec de récupérer `{rvest}`toutes les informations possibles sur chacun des profils présentés [sur la page consacrée aux ancien·nes sur le site de l'IPJ](https://www.ipj.eu/parcours-des-anciens/) et de les compiler dans un dataframe.

#### Etapes

1. identifier les données disponibles ;
2. tester les xPath ;
3. assembler dans une dataframe.

]

.pull-right[#### Le code source
![](./img/code_source.png)

Vous disposiez déjà de :


```r
nom &lt;- read_html("https://www.ipj.eu/parcours-des-anciens/") %&gt;% html_nodes(xpath = "//a[@class='team-member-name']") %&gt;% html_text(trim = TRUE)
lien &lt;- read_html("https://www.ipj.eu/parcours-des-anciens/") %&gt;% html_nodes(xpath = "//a[@class='team-member-name']") %&gt;% html_attr(name = "href")
```

]


---

### Correction 1/2

Pour récupérer la source de l'image, vous pouviez utiliser la class de la div contenant le lien contenant l'image.

Plusieurs d'entre vous ont proposé ce xPath tout à fait valide :


```r
read_html("https://www.ipj.eu/parcours-des-anciens/") %&gt;%
  html_nodes(xpath = "//div[@class='team-thumbnail a_position-relative a_width-100-per a_height-100-per a_overflow-hidden rounded-false']/a/img") %&gt;% html_attr(name = "src") %&gt;% head()
```

```
## [1] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/Bertrand-HOCHET-2-500x500-n8khmr1o2yg5xslp0hdbts8xcg1ozwrrjou5ugzn9k.jpg"                      
## [2] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/38-500x500-n5m3ow6dlq215jvsv0pzrs54v6gg218frnmlh1v3ig.jpg"                                     
## [3] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/Caroline-Laurent-Simon_visuel_article3-500x500-n5m3nk8lx68epftfmy00qm8mkj0q5gy4l2ctzxu6bs.jpeg"
## [4] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/chabaudcatherine-500x500-n5m3bqfpx81im2zxpby0v3otgzbgakzpyitvlldimg.jpeg"                      
## [5] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/dummy-7-n5a1yevqwz0ct8scgkp6n1hrlc8reatuz5j9rtly14.png"                                        
## [6] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/7-500x500-n5m40pz9lo8x8wpasmrznaoxyq5pwx6ue75jvebr7s.jpg"
```

--

Je vous propose une alternative, plus compacte, qui mobilise la fonction `starts-with()`. Plus compacte, elle est également plus lisible en restant tout à fait valide :


```r
read_html("https://www.ipj.eu/parcours-des-anciens/") %&gt;%
  html_nodes(xpath = "//div[starts-with(@class, 'team-thumbnail')]/a/img") %&gt;% html_attr(name = "src") %&gt;% head()
```

```
## [1] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/Bertrand-HOCHET-2-500x500-n8khmr1o2yg5xslp0hdbts8xcg1ozwrrjou5ugzn9k.jpg"                      
## [2] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/38-500x500-n5m3ow6dlq215jvsv0pzrs54v6gg218frnmlh1v3ig.jpg"                                     
## [3] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/Caroline-Laurent-Simon_visuel_article3-500x500-n5m3nk8lx68epftfmy00qm8mkj0q5gy4l2ctzxu6bs.jpeg"
## [4] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/chabaudcatherine-500x500-n5m3bqfpx81im2zxpby0v3otgzbgakzpyitvlldimg.jpeg"                      
## [5] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/dummy-4-n5a1yevqwz0ct8scgkp6n1hrlc8reatuz5j9rtly14.png"                                        
## [6] "https://www.ipj.eu/wp-content/uploads/bfi_thumb/7-500x500-n5m40pz9lo8x8wpasmrznaoxyq5pwx6ue75jvebr7s.jpg"
```

---


### Correction 2/2

De la même manière, la chaîne de caractères *team-member-position* pour l'attribut `class` suffit à identifier la bonne balise contenant le poste :


```r
read_html("https://www.ipj.eu/parcours-des-anciens/") %&gt;%
  html_nodes(xpath = "//span[starts-with(@class, 'team-member-position')]") %&gt;% html_text(trim = TRUE) %&gt;% head()
```

```
## [1] "Journaliste et Réd. chef adjoint / France Bleu Maine"
## [2] "Journaliste présentatrice / Franceinfo"              
## [3] "Grand reporter"                                      
## [4] "Navigatrice"                                         
## [5] "Directrice de RFI"                                   
## [6] "Grand reporter / RTL"
```

---

### Aparté : le Rmd 1/2

Comme son nom l'indique, le **Rmd** est un format ajoutant les fonctionnalités de **R** à celles d'un **markdown**.

Sous R, le package `{knitr}` permet de compiler un Rmd en trois formats au choix : PDF, HTML ou docx. Pour ce faire, il suffit de cliquer sur le bouton **Knit** en haut de l'interface Rstudio (ou avec *Ctrl/Cmd + Shift + k*).

#### Côté markdown

Le markdown est un métalangage de mise en forme qui repose sur un système de balisage simple et léger :
* `#` pour un titre de niveau 1 ;
* `##` pour un titre de niveau 2 et ainsi de suite ;
* `*` en balise pour ital, `**` pour la graisse ;
* `[nom](url)` avec le texte entre croches et le lien entre parenthèses pour un hypertexte ;
* `![alt](src)` avec le lien vers l'image pour afficher une image.

---

### Aparté : le Rmd 2/2

#### Côté R

La principale fonctionnalité R est l'intégration de *chunks*, des *"morceaux"*, de code R à l'intérieur d'un Markdown. Le Rmd affiche la sortie des opérations.

Pour ajouter un chunk, vous pouvez utiliser le raccourci *Ctrl/Cmd + Alt + i*.

Certaines fonctions sont spécialement conçues pour les Rmd, comme `kable()` du package `{knitr}`, qui permet un affichage optimal des tables. 

Il est également possible d'afficher les sorties visuelles :
* dataviz ;
* cartes interactives ;
* tableaux interactifs ;
* apps ;
* etc.

---

background-image: url("https://media.giphy.com/media/uWzDsAsRm2X9qULHLs/giphy.gif")
class: center, top, inverse

# 2. Des données "propres"

---

## Pourquoi "nettoyer" ses données ?

Le nettoyage de données, tâche fastidieuse (50 à 80% du temps des professionnelles de la data, [selon un article du NYTimes de 2014](https://www.nytimes.com/2014/08/18/technology/for-big-data-scientists-hurdle-to-insights-is-janitor-work.html)), est nécessaire car la plupart des données sont livrées dans le format correspondant aux besoins du/de la producteur·rice et non des réutilisateur·rices.

La notion de "données propres" (*clean data*) se réfère ainsi à l'usage et non pas à un standard universel : **chaque usage d'un jeu de données par un·e utilisateur·rice amènera à des critères de *propreté* différents**.

---

### Quelques principes généraux de nettoyage



Nous pouvons néanmoins énoncer quelques généralités :
* est propre un jeu de données où chaque donnée est lue suivant **le type** attendu ;
* est propre un jeu de données où les valeurs d'une même variable répondent à **une nomenclature** stable et lisible ;
* est propre un jeu de données dont **les variables sont renseignées de manière claire et cohérente** par rapport au schéma général ;
* est propre un jeu de données où **les données utiles sont formattées de manière à pouvoir être manipulées facilement**

Trois notions clefs vont donc nous servir de guide pour nettoyer nos données : le typage, le nommage, la complétude et le formattage.

---

### Un exemple de structure : les "tidy data"

![](./img/tidydata.png)


.pull-left[Cette structure de base est le modèle proposé par *Hadley Wickham*, créateur du `{tidyverse}`, le modèle **tidy data**.

Cette approche vise à simplifier la lecture et la manipulation des données.]

.pull-right[
.right[
![](./img/hadley.jpg)
]
]




---

## Apprendre à regarder ses données

La première étape du nettoyage consiste à examiner ses données afin d'en connaître les traits généraux : combien de variables ? Combien de valeur par variable ? Quelle est leur distribution ? Quel rapport entretiennent-elles entre elles ? Y a-t-il des valeurs non renseignées ? Etc.

`{R base}` et le `{tidyverse}` offrent de nombreux outils d'exploration préalables qui permettent de créer des aperçus des données.

---

### head() : les premières lignes

Votre premier réflexe face à une base de données, c'est de voir *"comment elle se présente"*. Pour se faire, la fonction `head()` est un bon point d'entrée : elle propose en sortie les 6 premières observations d'un jeu de données.

Pour voir les dernières observations, vous pouvez utiliser sa fonction miroir, `tail()`. Il est possible de paramétrer le nom d'observations affichées en passant à l'argument `n` la valeur correspondante.

Jettons un oeil aux premières lignes du jeu de données 4 du Répertoire national des élu·es (ou RNE) [disponible sur Data.gouv.fr](https://www.data.gouv.fr/en/datasets/repertoire-national-des-elus-1/), consacré aux conseiller·ères régionaux·les :


```r
rne4 &lt;- read_tsv("./data/2020-09-01-rne-cr.txt",
                 skip = 1, locale = locale(encoding = "ISO-8859-1"))

head(rne4)
```

```
## # A tibble: 6 x 13
##   `Code région` `Libellé de la … `Code du départ… `Libellé de dép…
##   &lt;chr&gt;         &lt;chr&gt;            &lt;chr&gt;            &lt;chr&gt;           
## 1 01            Guadeloupe       ZA               GUADELOUPE      
## 2 01            Guadeloupe       ZA               GUADELOUPE      
## 3 01            Guadeloupe       ZA               GUADELOUPE      
## 4 01            Guadeloupe       ZA               GUADELOUPE      
## 5 01            Guadeloupe       ZA               GUADELOUPE      
## 6 01            Guadeloupe       ZA               GUADELOUPE      
## # … with 9 more variables: `Nom de l'élu` &lt;chr&gt;, `Prénom de l'élu` &lt;chr&gt;, `Code
## #   sexe` &lt;chr&gt;, `Date de naissance` &lt;chr&gt;, `Code profession` &lt;dbl&gt;, `Libellé
## #   de la profession` &lt;chr&gt;, `Date de début du mandat` &lt;chr&gt;, `Libellé de
## #   fonction` &lt;chr&gt;, `Date de début de la fonction` &lt;chr&gt;
```

---

### glimpse() : une synthèse des dimensions

Une fois ce premier aperçu parcouru, il est nécessaire de disposer d'une image plus générale. La première étape consiste à regarder les variables du jeu de données et leur type.

Le `{tidyverse}` propose pour cela une fonction très compacte et pratique : `glimpse()`. Quand un jeu de données lui est passé, `glimpse()` produit une synthèse rapide : nombre de ligne, nombre de colonne et premières valeurs pour chacune des variables à disposition ainsi que son type.


```r
glimpse(rne4)
```

```
## Rows: 1,747
## Columns: 13
## $ `Code région`                  &lt;chr&gt; "01", "01", "01", "01", "01", "01", "0…
## $ `Libellé de la région`         &lt;chr&gt; "Guadeloupe", "Guadeloupe", "Guadeloup…
## $ `Code du département`          &lt;chr&gt; "ZA", "ZA", "ZA", "ZA", "ZA", "ZA", "Z…
## $ `Libellé de département`       &lt;chr&gt; "GUADELOUPE", "GUADELOUPE", "GUADELOUP…
## $ `Nom de l'élu`                 &lt;chr&gt; "ARMOUGOM", "BAILLET", "BAJAZET", "BAP…
## $ `Prénom de l'élu`              &lt;chr&gt; "Betty", "Patricia", "Clodomir", "Chri…
## $ `Code sexe`                    &lt;chr&gt; "F", "F", "M", "M", "M", "F", "M", "M"…
## $ `Date de naissance`            &lt;chr&gt; "9/7/1965", "17/6/1970", "3/5/1941", "…
## $ `Code profession`              &lt;dbl&gt; 118, 33, 162, 33, 74, 143, 31, 37, 105…
## $ `Libellé de la profession`     &lt;chr&gt; "Cadres supérieurs (secteur privé) (ob…
## $ `Date de début du mandat`      &lt;chr&gt; "13/12/2015", "13/12/2015", "13/12/201…
## $ `Libellé de fonction`          &lt;chr&gt; NA, NA, NA, "Autre membre commission p…
## $ `Date de début de la fonction` &lt;chr&gt; NA, NA, NA, "18/12/2015", NA, NA, NA, …
```

---

### summary() : une synthèse des variables

`{rbase}` offre une fonction complémentaire de `glimpse()` avec `summary()`.

`summary()` analyse le jeu de données et, plutôt qu'un aperçu de quelques valeurs, propose une synthèse par variable (notamment des éléments de distribution). A ce titre, **`summary()` s'avère beaucoup plus adapté pour survoler un jeu de données contenant des données numériques que pour les chaînes de caractère**.



```r
summary(rne4)
```

```
##  Code région        Libellé de la région Code du département
##  Length:1747        Length:1747          Length:1747        
##  Class :character   Class :character     Class :character   
##  Mode  :character   Mode  :character     Mode  :character   
##                                                             
##                                                             
##                                                             
##                                                             
##  Libellé de département Nom de l'élu       Prénom de l'élu   
##  Length:1747            Length:1747        Length:1747       
##  Class :character       Class :character   Class :character  
##  Mode  :character       Mode  :character   Mode  :character  
##                                                              
##                                                              
##                                                              
##                                                              
##   Code sexe         Date de naissance  Code profession 
##  Length:1747        Length:1747        Min.   : 11.00  
##  Class :character   Class :character   1st Qu.: 37.00  
##  Mode  :character   Mode  :character   Median : 86.00  
##                                        Mean   : 89.95  
##                                        3rd Qu.:141.00  
##                                        Max.   :165.00  
##                                        NA's   :8       
##  Libellé de la profession Date de début du mandat Libellé de fonction
##  Length:1747              Length:1747             Length:1747        
##  Class :character         Class :character        Class :character   
##  Mode  :character         Mode  :character        Mode  :character   
##                                                                      
##                                                                      
##                                                                      
##                                                                      
##  Date de début de la fonction
##  Length:1747                 
##  Class :character            
##  Mode  :character            
##                              
##                              
##                              
## 
```


---

### table() : la distribution sur une variable

La distribution des valeurs est la façon dont l'ensemble des valeurs sont réparties sur la gamme des valeurs possibles dans la base de données. Il s'agit d'un outil d'analyse très utile pour les données numériques mais tout autant pour les chaînes de caractère ou les booléens.

La fonction de `{rbase}` `table()` permet de réaliser une synthèse de la distribution des valeurs pour une variable d'un jeu de données. Elle prend pour argument la base de données suivie de `$nomdelavariable`. Par exemple, si nous souhaitons connaître la distribution des `Libellé de fonction`, nous pouvons appeler cette fonction de la manière suivante :


```r
rne4 &lt;- rename(rne4, c("fonction"="Libellé de fonction")) # d'abord, renommons cette variable relou

table(rne4$fonction)
```

```
## 
##             Autre membre commission permanente 
##                                            288 
##   Cinquième vice-président du conseil régional 
##                                             14 
##     Dixième vice-président du conseil régional 
##                                             12 
##    Douzième vice-président du conseil régional 
##                                             12 
##    Huitième vice-président du conseil régional 
##                                             13 
##    Neuvième vice-président du conseil régional 
##                                             13 
##     Onzième vice-président du conseil régional 
##                                             12 
##     Premier vice-président du conseil régional 
##                                             13 
##                        Président de commission 
##                                             14 
##                  Président du conseil régional 
##                                             14 
## Quatorzième vice-président du conseil régional 
##                                             11 
##   Quatrième vice-président du conseil régional 
##                                             14 
##   Quinzième vice-président du conseil régional 
##                                              9 
##      Second vice-président du conseil régional 
##                                             12 
##    Septième vice-président du conseil régional 
##                                             14 
##     Sixième vice-président du conseil régional 
##                                             15 
##   Treizième vice-président du conseil régional 
##                                             11 
##   Troisième vice-président du conseil régional 
##                                             12
```


---

### is.na() : la présence de NAs

Vous n'avez rien remarqué de bizarre dans le précédent compte ?

Comment se fait-il que nous ayons 14 régions mais seulement 13 Premier·ères vice-président·es ?

--

Pour savoir si une valeur correspond à une type de données, `{rbase}` propose une série de fonction de test : `is.*()` : `is.numeric()`, `is.logical()` ... et `is.na()` pour savoir si la valeur est NA ou non.

En la combinant avec `table()`, nous obtenons une synthèse sur le nombre de TRUE et de FALSE :

```r
table(is.na(rne4$fonction))
```

```
## 
## FALSE  TRUE 
##   503  1244
```

Nous avons donc bien un problème sur cette variable, qu'on dira *"mal renseignée"*.

---

### Mesurer les éléments

Plusieurs foncitons permettent de connaître la longueur d'un objet dans R :
* `length()` : pour la longueur d'un vecteur ;
* `nrow()` / `ncol()` : pour le nombre de ligne ou colonne d'un dataframe ;
* `nchar()` : pour le nombre de caractères d'une chaîne de caractère.



```r
length(rne4$`Libellé de la région`)
```

```
## [1] 1747
```

```r
nrow(rne4)
```

```
## [1] 1747
```

```r
nchar(rne4$`Libellé de la région`)
```

```
##    [1] 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10
##   [25] 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10
##   [49] 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10
##   [73] 10 10 10 10 10 10 10 10 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13
##   [97] 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13
##  [121] 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13
##  [145] 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13
##  [169] 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13
##  [193] 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13
##  [217] 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13
##  [241] 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13
##  [265] 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13 13
##  [289] 13 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19
##  [313] 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19
##  [337] 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19 19
##  [361] 19 19 19 19 19 19 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
##  [385] 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
##  [409] 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
##  [433] 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23 23
##  [457] 23 23 23 23 23 23 23 23 23 23 23  9  9  9  9  9  9  9  9  9  9  9  9  9
##  [481]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
##  [505]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
##  [529]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
##  [553]  9  9  9  9  9  9  9  9  9  9  9  9  9  9 15 15 15 15 15 15 15 15 15 15
##  [577] 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15
##  [601] 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15
##  [625] 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15
##  [649] 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15
##  [673] 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15
##  [697] 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15
##  [721] 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15 15  9  9  9  9  9  9  9  9
##  [745]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
##  [769]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
##  [793]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
##  [817]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
##  [841]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
##  [865]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
##  [889]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9 16 16 16 16 16 16 16
##  [913] 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
##  [937] 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
##  [961] 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16 16
##  [985] 16 16 16 16 16 16 16 16 16 16 16 16 16 16  8  8  8  8  8  8  8  8  8  8
## [1009]  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8
## [1033]  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8
## [1057]  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8  8
## [1081]  8 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18
## [1105] 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18
## [1129] 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18
## [1153] 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18
## [1177] 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18
## [1201] 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18
## [1225] 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18
## [1249] 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18 18  9  9  9  9  9  9  9
## [1273]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
## [1297]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
## [1321]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
## [1345]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
## [1369]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
## [1393]  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9  9
## [1417]  9  9  9  9 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
## [1441] 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
## [1465] 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
## [1489] 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
## [1513] 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
## [1537] 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
## [1561] 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
## [1585] 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20
## [1609] 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 26 26 26 26 26 26 26 26
## [1633] 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
## [1657] 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
## [1681] 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
## [1705] 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
## [1729] 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26 26
```


---

### Aparté : les tests 1/2

L'informatique repose en grande partie sur les valeurs booléennes : TRUE / FALSE, 1 / 0, etc. Ce type de valeur a de nombreuses qualités : elle s'avère facile à produire, lire, stocker et sans risque d'ambiguïté.

Un *test* est une opération par laquelle une propriété est évaluée sur un objet : si la propriété est remplie, le test sera dit *"vrai"* (*TRUE*), sinon, il sera dit *"faux"* (*FALSE*). Ce sont des questions fermées.

Les tests de base sont réalisés avec les opérateurs dits logiques :
* égalité `==` ;
* supérieur ou égal `&gt;=` / inférieur ou égal `&lt;=` ;
* strictement supérieur `&gt;` / strictement inférieur `&lt;` ;
* différent `!=`.


```r
5 &gt; 2
```

```
## [1] TRUE
```

Il existe de nombreuses fonctions permettant de réaliser des tests (notamment les fonctions `is.*()` évoquées dans la slide précédente).

---

### Aparté : les tests 2/2

La plupart des outils que nous manipulons en R procède par des tests implicites ou explicitent. Nous pourrions résumer le principe par la question :
*"Faut-il appliquer l'opération à l'élément de rang N ?"*

Aquoi l'on peut répondre par oui ou par non.

En R, quand un test est réalisé sur un vecteur, il renvoie un vecteur de même longueur dont chaque valeur est le résultat du test sur la valeur du vecteur d'origine. Par exemple :

```r
vecteur &lt;- c(3,1,9,15,22)
vecteur &gt; 10
```

```
## [1] FALSE FALSE FALSE  TRUE  TRUE
```

---

background-image: url("https://media.giphy.com/media/PmABbbUe3IqUKSOIBV/giphy.gif")
class: center, top, inverse

# 3. Trier et organiser ses données

---

## filter() : pour choisir les observations

La fonction `filter()` du package `{dplyr}` va nous permettre de sélectionner les observation suivant une ou plusieurs conditions.

La fonction `filter()` appelle un ou plusieurs tests portant sur une ou plusieurs variables :


```r
rne4 &lt;- rne4 %&gt;%  setNames(c("region_code","region_nom","dep_code","dep_nom","elu_nom","elu_prenom",
                   "sexe","date_naissance","profession_code","profession_nom","date_mandat",
                   "fonction","fonction_date"))

rne4 %&gt;% filter(sexe == "F")
```

```
## # A tibble: 838 x 13
##    region_code region_nom dep_code dep_nom elu_nom elu_prenom sexe 
##    &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;
##  1 01          Guadeloupe ZA       GUADEL… ARMOUG… Betty      F    
##  2 01          Guadeloupe ZA       GUADEL… BAILLET Patricia   F    
##  3 01          Guadeloupe ZA       GUADEL… BONDOT  Gersiane   F    
##  4 01          Guadeloupe ZA       GUADEL… CELIGNY Maguy      F    
##  5 01          Guadeloupe ZA       GUADEL… CEROL   Nita       F    
##  6 01          Guadeloupe ZA       GUADEL… CONVER… Ginette    F    
##  7 01          Guadeloupe ZA       GUADEL… DAGONIA Sylvie     F    
##  8 01          Guadeloupe ZA       GUADEL… DECAST… Monique, … F    
##  9 01          Guadeloupe ZA       GUADEL… DESTOU… Annick     F    
## 10 01          Guadeloupe ZA       GUADEL… FAITHF… Lucianne   F    
## # … with 828 more rows, and 6 more variables: date_naissance &lt;chr&gt;,
## #   profession_code &lt;dbl&gt;, profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;,
## #   fonction &lt;chr&gt;, fonction_date &lt;chr&gt;
```


---

### Filtre à conditions multiples

La fonction `filter()` appelle un ou plusieurs tests portant sur une ou plusieurs variables :


```r
rne4 %&gt;% filter(fonction == "Président du conseil régional",
                sexe == "F")
```

```
## # A tibble: 4 x 13
##   region_code region_nom dep_code dep_nom elu_nom elu_prenom sexe 
##   &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;
## 1 11          Île-de-Fr… 78       YVELIN… PECRES… Valérie    F    
## 2 27          Bourgogne… 25       DOUBS   DUFAY   Marie-Gui… F    
## 3 52          Pays de l… 72       SARTHE  MORANÇ… Christelle F    
## 4 76          Occitanie  31       HAUTE … DELGA   Carole     F    
## # … with 6 more variables: date_naissance &lt;chr&gt;, profession_code &lt;dbl&gt;,
## #   profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;, fonction &lt;chr&gt;,
## #   fonction_date &lt;chr&gt;
```

---

### L'opérateur %in%

L'opérateur `%in%` permet de réaliser un test avec plusieurs possibilités fournies sous forme d'un vecteur.

Nous pouvons par exemple passer une liste de codes de régions pour en sélectionner plusieurs d'un coup :


```r
rne4 %&gt;% filter(region_code %in% c("11","27","44"))
```

```
## # A tibble: 479 x 13
##    region_code region_nom dep_code dep_nom elu_nom elu_prenom sexe 
##    &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;
##  1 11          Île-de-Fr… 75       PARIS   ANDROU… Mathilde   F    
##  2 11          Île-de-Fr… 75       PARIS   ANSEL   Maxence    F    
##  3 11          Île-de-Fr… 75       PARIS   BARIANI Didier     M    
##  4 11          Île-de-Fr… 75       PARIS   BAYOU   Julien     M    
##  5 11          Île-de-Fr… 75       PARIS   BENHAIM Frédéric   M    
##  6 11          Île-de-Fr… 75       PARIS   BERTHO… Florence   F    
##  7 11          Île-de-Fr… 75       PARIS   BOHBOT  Jack-Yves  M    
##  8 11          Île-de-Fr… 75       PARIS   BÜRKLI  Delphine   F    
##  9 11          Île-de-Fr… 75       PARIS   CAPLIEZ Stéphane   M    
## 10 11          Île-de-Fr… 75       PARIS   CARREY… Fanélie    F    
## # … with 469 more rows, and 6 more variables: date_naissance &lt;chr&gt;,
## #   profession_code &lt;dbl&gt;, profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;,
## #   fonction &lt;chr&gt;, fonction_date &lt;chr&gt;
```


---

### L'opérateur "!"

L'opérateur `!`, quand il précède un test, permet d'en inverser les critères et donc de "ne pas" sélectionner les observations qui correspondent au test.

Par exemple, nous pouvons inverser la sélectioner précédente en sélectionnant toutes les régions SAUF celles listées :


```r
rne4 %&gt;% filter(!(region_code %in% c("11","27","44")))
```

```
## # A tibble: 1,268 x 13
##    region_code region_nom dep_code dep_nom elu_nom elu_prenom sexe 
##    &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;
##  1 01          Guadeloupe ZA       GUADEL… ARMOUG… Betty      F    
##  2 01          Guadeloupe ZA       GUADEL… BAILLET Patricia   F    
##  3 01          Guadeloupe ZA       GUADEL… BAJAZET Clodomir   M    
##  4 01          Guadeloupe ZA       GUADEL… BAPTIS… Christian  M    
##  5 01          Guadeloupe ZA       GUADEL… BARDAIL Jean       M    
##  6 01          Guadeloupe ZA       GUADEL… BONDOT  Gersiane   F    
##  7 01          Guadeloupe ZA       GUADEL… BREDENT Georges    M    
##  8 01          Guadeloupe ZA       GUADEL… BRUDEY  Hilaire    M    
##  9 01          Guadeloupe ZA       GUADEL… CELIGNY Maguy      F    
## 10 01          Guadeloupe ZA       GUADEL… CEROL   Nita       F    
## # … with 1,258 more rows, and 6 more variables: date_naissance &lt;chr&gt;,
## #   profession_code &lt;dbl&gt;, profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;,
## #   fonction &lt;chr&gt;, fonction_date &lt;chr&gt;
```


---

### Exercice de filtre

Je vous demande de filtrer rne4 pour ne conserver que les élu·es dont le prénom comporte moins de 5 lettres.

--


```r
rne4 %&gt;% filter(nchar(elu_prenom) &lt; 5)
```

```
## # A tibble: 112 x 13
##    region_code region_nom dep_code dep_nom elu_nom elu_prenom sexe 
##    &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;
##  1 01          Guadeloupe ZA       GUADEL… BARDAIL Jean       M    
##  2 01          Guadeloupe ZA       GUADEL… CEROL   Nita       F    
##  3 01          Guadeloupe ZA       GUADEL… CHALUS  Ary        M    
##  4 01          Guadeloupe ZA       GUADEL… LOSBAR  Guy        M    
##  5 04          La Réunion ZD       LA REU… BEDIER  Joé        M    
##  6 04          La Réunion ZD       LA REU… GAUTHI… Jack       M    
##  7 04          La Réunion ZD       LA REU… GUEZEL… Alin       M    
##  8 04          La Réunion ZD       LA REU… VIENNE  Axel       M    
##  9 11          Île-de-Fr… 75       PARIS   WEHRLI… Yann       M    
## 10 11          Île-de-Fr… 77       SEINE … CHAIN-… Anne       F    
## # … with 102 more rows, and 6 more variables: date_naissance &lt;chr&gt;,
## #   profession_code &lt;dbl&gt;, profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;,
## #   fonction &lt;chr&gt;, fonction_date &lt;chr&gt;
```


---

## select() : pour choisir ses variables

La fonction `select()`de `{dplyr}` permet de sélectionner les variables jugées utiles ou pertinentes.

Cela comporte deux intérêts principaux :
1. alléger votre jeu de données pour rendre les opérations plus rapides ;
2. simplifier la lecture de votre jeu de données.

La manière la plus simple d'utiliser `select()`consiste à lister les variables retenues par leur nom :


```r
rne4 %&gt;% select(elu_nom, elu_prenom, sexe)
```

```
## # A tibble: 1,747 x 3
##    elu_nom  elu_prenom sexe 
##    &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;
##  1 ARMOUGOM Betty      F    
##  2 BAILLET  Patricia   F    
##  3 BAJAZET  Clodomir   M    
##  4 BAPTISTE Christian  M    
##  5 BARDAIL  Jean       M    
##  6 BONDOT   Gersiane   F    
##  7 BREDENT  Georges    M    
##  8 BRUDEY   Hilaire    M    
##  9 CELIGNY  Maguy      F    
## 10 CEROL    Nita       F    
## # … with 1,737 more rows
```


---

### De multiples façons de sélectionner

La fonction `select()` offre d'autres possibilités de sélection :
* **par index** en indiquant le rang des variables retenues ;
* **par un vecteur** soit en listant les noms des variables comme chaînes de caractères, soit par index.




```r
rne4 %&gt;% select(1:5) %&gt;% head() # affichera les 5 premières variables
```

```
## # A tibble: 6 x 5
##   region_code region_nom dep_code dep_nom    elu_nom 
##   &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;   
## 1 01          Guadeloupe ZA       GUADELOUPE ARMOUGOM
## 2 01          Guadeloupe ZA       GUADELOUPE BAILLET 
## 3 01          Guadeloupe ZA       GUADELOUPE BAJAZET 
## 4 01          Guadeloupe ZA       GUADELOUPE BAPTISTE
## 5 01          Guadeloupe ZA       GUADELOUPE BARDAIL 
## 6 01          Guadeloupe ZA       GUADELOUPE BONDOT
```

```r
rne4 %&gt;% select(c("elu_nom","elu_prenom","region_nom")) %&gt;% head()
```

```
## # A tibble: 6 x 3
##   elu_nom  elu_prenom region_nom
##   &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;     
## 1 ARMOUGOM Betty      Guadeloupe
## 2 BAILLET  Patricia   Guadeloupe
## 3 BAJAZET  Clodomir   Guadeloupe
## 4 BAPTISTE Christian  Guadeloupe
## 5 BARDAIL  Jean       Guadeloupe
## 6 BONDOT   Gersiane   Guadeloupe
```


---

### Les helpers

Le "verbe" `select()` (suivant la nomenclature du `{tidyverse}`) propose également des **helpers functions** (abrégées *helpers*) qui permettent de réaliser des sélections plus fines, notamment en utilisant des expressions régulières.

Par exemple, le helper `starts_with()` permet de soumettre une chaîne de caractères qui doit figurer au début du nom de la variable pour qu'elle soit retenue :


```r
rne4 %&gt;% select(starts_with("elu"), date_naissance) %&gt;% head()
```

```
## # A tibble: 6 x 3
##   elu_nom  elu_prenom date_naissance
##   &lt;chr&gt;    &lt;chr&gt;      &lt;chr&gt;         
## 1 ARMOUGOM Betty      9/7/1965      
## 2 BAILLET  Patricia   17/6/1970     
## 3 BAJAZET  Clodomir   3/5/1941      
## 4 BAPTISTE Christian  18/6/1962     
## 5 BARDAIL  Jean       30/5/1951     
## 6 BONDOT   Gersiane   9/2/1963
```

---

### Aparté : les regex



---

## mutate() : pour créer ou modifier ses variables

La fonction `mutate()` permet de modifier ou créer des variables. Elle appelle le nom de la variable créé et l'opération nécessaire pour la renseigner. Si le nom est le même qu'une variable existante, cette dernière la remplacera.

Pour le jeu de données `rne4`, nous pouvons par exemple convertir la variable `date_naissance` en date (ce qui peut s'avérer utile).

Pour cela, nous utiliserons la fonction `as.Date()` de `{rbase}` qui convertit une chaîne de caractères en date :


```r
rne4 %&gt;% mutate(date_naissance = as.Date(date_naissance,
                                         format = "%d/%m/%Y")) %&gt;% head()
```

```
## # A tibble: 6 x 13
##   region_code region_nom dep_code dep_nom elu_nom elu_prenom sexe 
##   &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt;
## 1 01          Guadeloupe ZA       GUADEL… ARMOUG… Betty      F    
## 2 01          Guadeloupe ZA       GUADEL… BAILLET Patricia   F    
## 3 01          Guadeloupe ZA       GUADEL… BAJAZET Clodomir   M    
## 4 01          Guadeloupe ZA       GUADEL… BAPTIS… Christian  M    
## 5 01          Guadeloupe ZA       GUADEL… BARDAIL Jean       M    
## 6 01          Guadeloupe ZA       GUADEL… BONDOT  Gersiane   F    
## # … with 6 more variables: date_naissance &lt;date&gt;, profession_code &lt;dbl&gt;,
## #   profession_nom &lt;chr&gt;, date_mandat &lt;chr&gt;, fonction &lt;chr&gt;,
## #   fonction_date &lt;chr&gt;
```

---

### Création de plusieurs variables

Il est possible de créer plusieurs variables d'un seul appel de `mutate()`. Il suffit de séparer les opérations par des virgules.

Les variables sont créées dans l'ordre où elles sont listées dans la fonction. Il est donc possible de créer des variables *"en cascade"*. Nous pouvons par exemple utiliser la fonction `year()` de la librairie `{lubridate}` pour extraire l'année sous forme de double :


```r
library(lubridate)

rne4 %&gt;% mutate(date_naissance = as.Date(date_naissance,
                                         format = "%d/%m/%Y"),
                annee_naissance = year(date_naissance)) %&gt;%
  dplyr::select(date_naissance, annee_naissance) %&gt;% 
  head()
```

```
## # A tibble: 6 x 2
##   date_naissance annee_naissance
##   &lt;date&gt;                   &lt;dbl&gt;
## 1 1965-07-09                1965
## 2 1970-06-17                1970
## 3 1941-05-03                1941
## 4 1962-06-18                1962
## 5 1951-05-30                1951
## 6 1963-02-09                1963
```


---

### Exemple de calcul complexe pour une variable

La création d'une variable peut parfois nécessité plusieurs opérations pour arriver à un résultat satisfaisant.

Par exemple, ici, **calculer l'âge** d'un·e élu·e nécessite plusieurs étapes :
1. convertir la variable `date_naissance` au bon format ;
2. récupérer la date du jour avec la fonction `today()` ;
3. calculer la différence entre la `date_naissance` et `today()` avec la fonction `difftime()` ;
4. le grain minimum étant la semaine (paramétré avec l'argument `units = "weeks"`), nous devrons diviser le résultat par 52.25 (nombre de semaine d'une année calendaire) ;
5. mais avant cela, il nous faudra convertir la sortie de `difftime()` en double avec `as.numeric()`.

---

En pratique, voilà ce que ça donne :


```r
rne4 %&gt;% mutate(date_naissance = as.Date(date_naissance, format = "%d/%m/%Y"),
                age = as.numeric(difftime(today(), date_naissance, units = "weeks"))/52.25) %&gt;% 
  dplyr::select(date_naissance, age)
```

```
## # A tibble: 1,747 x 2
##    date_naissance   age
##    &lt;date&gt;         &lt;dbl&gt;
##  1 1965-07-09      55.3
##  2 1970-06-17      50.4
##  3 1941-05-03      79.5
##  4 1962-06-18      58.4
##  5 1951-05-30      69.4
##  6 1963-02-09      57.7
##  7 1953-12-13      66.9
##  8 1960-03-27      60.6
##  9 1953-08-12      67.2
## 10 1963-11-28      56.9
## # … with 1,737 more rows
```

--

... et encore, on obtient un format double avec des décimales ! Pour le corriger, il faudra encapsuler le résultat dans la fonction `round()` en renseignant l'argument `digits = 0`.

---

### Exercice à vous !

Je vous demande de nettoyer cette base de la manière suivante :
1. ne retenez que les variables de nom et code des régions, nom et prénom des élu·es, sexe, date de naissance et date de début de mandat ;
2. renommez-les de la même manière que moi : "region_code", "dep_code", "elu_nom", "elu_prenom", "sexe", "date_naissance" ;
3. calculer une variable "age" pour chaque élu arrondit à 1 décimales ;
4. stocker le résultat dans une nouvelle variable : `rne4_c` pour rne4 compact.

--


```r
rne4_c &lt;- read_tsv("./data/2020-09-01-rne-cr.txt", skip = 1, locale = locale(encoding = "ISO-8859-1")) %&gt;%
  setNames(c("region_code","region_nom","dep_code","dep_nom","elu_nom","elu_prenom",
                   "sexe","date_naissance","profession_code","profession_nom","date_mandat",
                   "fonction","fonction_date")) %&gt;% 
  dplyr::select(region_code, region_nom, elu_nom, elu_prenom, sexe, date_naissance, date_mandat) %&gt;%
  mutate(date_naissance = as.Date(date_naissance, format = "%d/%m/%Y"),
         age = round(as.numeric(difftime(today(), date_naissance, units = "weeks"))/52.25, digits = 1))
```


---

background-image: url("https://media.giphy.com/media/xB2DKVtgNiJzZtAYht/giphy.gif")
class: center, top, inverse

# 4. Produire des synthèses

---

## Grouper et synthétiser

Les jeux de données s'avèrent généralement trop vastes pour pouvoir être analysés bruts. Qu'il s'agisse de chercher des pistes de sujet ou de réaliser des visualisations, vous aurez besoin de produire des synthèses se concentrant sur un aspect particulier du jeu de données.

Pour cela, la librairie `{dplyr}` propose deux fonctions complémentaires permettant de réaliser des *"synthèses groupées"* :
* `group_by()` qui permet de grouper les observations par les différentes valeurs d'une ou plusieurs variables ;
* `summarise()` qui permet de générer une variable calculer sur la base des groupes ainsi constitués.

---

### group_by()

Seule, la fonction `group_by()` ne "produit" rien. Elle laisse tout juste apparaître les groupes constitués suivant la liste de variable fournie.


```r
rne4_c %&gt;% group_by(sexe)
```

```
## # A tibble: 1,747 x 8
## # Groups:   sexe [2]
##    region_code region_nom elu_nom elu_prenom sexe  date_naissance date_mandat
##    &lt;chr&gt;       &lt;chr&gt;      &lt;chr&gt;   &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;         &lt;chr&gt;      
##  1 01          Guadeloupe ARMOUG… Betty      F     1965-07-09     13/12/2015 
##  2 01          Guadeloupe BAILLET Patricia   F     1970-06-17     13/12/2015 
##  3 01          Guadeloupe BAJAZET Clodomir   M     1941-05-03     13/12/2015 
##  4 01          Guadeloupe BAPTIS… Christian  M     1962-06-18     13/12/2015 
##  5 01          Guadeloupe BARDAIL Jean       M     1951-05-30     13/12/2015 
##  6 01          Guadeloupe BONDOT  Gersiane   F     1963-02-09     13/12/2015 
##  7 01          Guadeloupe BREDENT Georges    M     1953-12-13     13/12/2015 
##  8 01          Guadeloupe BRUDEY  Hilaire    M     1960-03-27     13/12/2015 
##  9 01          Guadeloupe CELIGNY Maguy      F     1953-08-12     13/12/2015 
## 10 01          Guadeloupe CEROL   Nita       F     1963-11-28     13/12/2015 
## # … with 1,737 more rows, and 1 more variable: age &lt;dbl&gt;
```


---

### summarise()

La fonction `summarise()` permet de générer de nouvelles variables, à la manière de `mutate()`, avec une différence notable : elle le fait sur la base des groupes constitués avec `group_by()` et en supprimant toutes les autres variables.

Si nous groupons comme à la slide précédente le jeu de données par sexe, il nous est possible de calculer l'âge moyen *"par sexe"* en utilisant la fonction `summarise()` en aval de `group_by(sexe)` :

--


```r
rne4_c %&gt;% group_by(sexe) %&gt;% summarise(age_moyen = mean(age))
```

```
## # A tibble: 2 x 2
##   sexe  age_moyen
##   &lt;chr&gt;     &lt;dbl&gt;
## 1 F          54.2
## 2 M          55.2
```

Je souligne ici l'expression *"calculer par sexe"* car elle me semble bien résumer la façon dont fonctionne le *grouping*.

---

### Multigrouping

Il est possible de passer plus d'un nom de variable à `group_by()`. `summarise()` procédera alors par un calcul sur chacun des groupes croisés, c'est-à-dire toutes les combinaisons possibles des valeurs de chaque variable.

Nous pouvons ainsi complexifier notre synthèse sur les âges moyens par sexe en y ajoutant le critère de la région :


```r
rne4_c %&gt;% group_by(region_nom, sexe) %&gt;%
  summarise(age_moyen = mean(age)) %&gt;% head()
```

```
## # A tibble: 6 x 3
## # Groups:   region_nom [3]
##   region_nom              sexe  age_moyen
##   &lt;chr&gt;                   &lt;chr&gt;     &lt;dbl&gt;
## 1 Auvergne-Rhône-Alpes    F          52.9
## 2 Auvergne-Rhône-Alpes    M          54.9
## 3 Bourgogne-Franche-Comté F          54.5
## 4 Bourgogne-Franche-Comté M          52.7
## 5 Bretagne                F          55  
## 6 Bretagne                M          53.8
```


---

### count() 1/2

Il peut être tentant d'utiliser la synthèse groupée pour calculer le nombre d'élément par groupe avec la fonction `n()`. Si nous voulions calculer le nombre d'homme et de femme par région, nous pourrions procéder ainsi  :

```r
rne4 %&gt;% group_by(region_nom, sexe) %&gt;% summarise(n = n())
```

```
## # A tibble: 28 x 3
## # Groups:   region_nom [14]
##    region_nom              sexe      n
##    &lt;chr&gt;                   &lt;chr&gt; &lt;int&gt;
##  1 Auvergne-Rhône-Alpes    F       100
##  2 Auvergne-Rhône-Alpes    M       104
##  3 Bourgogne-Franche-Comté F        47
##  4 Bourgogne-Franche-Comté M        54
##  5 Bretagne                F        40
##  6 Bretagne                M        43
##  7 Centre-Val de Loire     F        34
##  8 Centre-Val de Loire     M        43
##  9 Grand Est               F        81
## 10 Grand Est               M        88
## # … with 18 more rows
```

---

### count() 2/2

Une façon beaucoup plus simple et directe de le faire consiste à appeler la fonction `count()` en spécifiant pour argument les variables par lesquelles on souhaite grouper :


```r
rne4 %&gt;% count(region_nom, sexe)
```

```
## # A tibble: 28 x 3
##    region_nom              sexe      n
##    &lt;chr&gt;                   &lt;chr&gt; &lt;int&gt;
##  1 Auvergne-Rhône-Alpes    F       100
##  2 Auvergne-Rhône-Alpes    M       104
##  3 Bourgogne-Franche-Comté F        47
##  4 Bourgogne-Franche-Comté M        54
##  5 Bretagne                F        40
##  6 Bretagne                M        43
##  7 Centre-Val de Loire     F        34
##  8 Centre-Val de Loire     M        43
##  9 Grand Est               F        81
## 10 Grand Est               M        88
## # … with 18 more rows
```

---

### arrange()

Une fois certains calculs réalisés, il peut être intéressant d'ordonner les résultats suivant une variable pour trouver les valeurs les plus ou moins élevées.

La fonction `arrange()` permet de réaliser cette opération suivant deux modalités :
* `arrange(variable)` : triera par ordre croissant les valeurs de la variable passée en argument ;
* `arrange(desc(variable))` : triera par ordre décroissant les valeurs de la variable passée en argument.

---

#### Exemple : arrange()

Nous pouvons ainsi voir où la moyenne d'âge des conseillers régionaux est la plus basse en quelques opératons :


```r
rne4_c %&gt;% 
  group_by(region_nom, sexe) %&gt;%
  summarise(age_moyen = mean(age)) %&gt;% 
  filter(sexe == "M") %&gt;% 
  arrange(age_moyen)
```

```
## # A tibble: 14 x 3
## # Groups:   region_nom [14]
##    region_nom                 sexe  age_moyen
##    &lt;chr&gt;                      &lt;chr&gt;     &lt;dbl&gt;
##  1 Bourgogne-Franche-Comté    M          52.7
##  2 Hauts-de-France            M          53.0
##  3 Île-de-France              M          53.2
##  4 Bretagne                   M          53.8
##  5 Pays de la Loire           M          54.2
##  6 Auvergne-Rhône-Alpes       M          54.9
##  7 Grand Est                  M          55.0
##  8 Normandie                  M          55.6
##  9 Provence-Alpes-Côte d'Azur M          55.7
## 10 Nouvelle-Aquitaine         M          56.4
## 11 Centre-Val de Loire        M          56.8
## 12 Occitanie                  M          57.0
## 13 La Réunion                 M          61.8
## 14 Guadeloupe                 M          62.3
```

---

### WARNING : pensez à dégrouper !

L'opération `group_by()` semble "indolore" mais elle modifie en fait les métadonnées d'un jeu de données. Il est recommandé de *"dégrouper"* après avoir réalisé votre synthèse pour éviter de rencontrer des erreurs.

La fonction `ungroup()` permet de supprimer les groupings dans un jeu de données. La seule indication dont vous disposerez cependant, c'est l'absence de l'annonce des *"groups"* en tête de la sortie de votre pipeline :


```r
rne4_c %&gt;% 
  group_by(region_nom, sexe) %&gt;%
  summarise(age_moyen = mean(age)) %&gt;% 
  filter(sexe == "M") %&gt;% 
  arrange(age_moyen) %&gt;% 
  ungroup()
```

```
## # A tibble: 14 x 3
##    region_nom                 sexe  age_moyen
##    &lt;chr&gt;                      &lt;chr&gt;     &lt;dbl&gt;
##  1 Bourgogne-Franche-Comté    M          52.7
##  2 Hauts-de-France            M          53.0
##  3 Île-de-France              M          53.2
##  4 Bretagne                   M          53.8
##  5 Pays de la Loire           M          54.2
##  6 Auvergne-Rhône-Alpes       M          54.9
##  7 Grand Est                  M          55.0
##  8 Normandie                  M          55.6
##  9 Provence-Alpes-Côte d'Azur M          55.7
## 10 Nouvelle-Aquitaine         M          56.4
## 11 Centre-Val de Loire        M          56.8
## 12 Occitanie                  M          57.0
## 13 La Réunion                 M          61.8
## 14 Guadeloupe                 M          62.3
```



---


background-image: url("https://media.giphy.com/media/ZwF94oelvrAuxIKtRS/giphy.gif")
class: center, top

### Exercice de synthèse

Je vous demande trouver :
* un record sur les prénoms ;
* un record sur l'âge ;
* un record sur le genre.

---

background-image: url("https://media.giphy.com/media/4N5wG6y1RW4ee0pAPY/giphy.gif")
class: center, top, inverse

# 5. L'exercice de la semaine


---

## Trois faits notables sur les élu·es des départements

Je vous demande de réaliser une exploration du jeu de données des conseillers départementaux [de la base de données RNE](https://www.data.gouv.fr/en/datasets/repertoire-national-des-elus-1/).

Vous utiliserez les techniques présentées ici (et toutes celles qui vous paraîtrons pertinentes) pour explorer trois thématiques :
* le genre ;
* l'âge ;
* la profession.

Pour chaque thématique, vous présenterez une synthèse qui souligne un fait saillant dans la base.

#### Rendu
Votre travail est demandé en format .Rmd par mail (n'hésitez pas faire plusieurs bouts de code pour le rendre plus lisible).

* le titre du fichier devra être : *"ipj_ddj_exo03_prenomnom.Rmd"* ;
* le titre de votre mail devra être : *"IPJ - DDJ - rendu exo03"*]

---

background-image: url("https://media.giphy.com/media/3s6GaByTfXDk8RXKDh/giphy.gif")
class: center, top, inverse

## La prochaine fois, nous passons à l'analyse


---
class: inverse, center, middle

# Merci !


Contact : [sylvainlapoix@gmail.com](mailto:sylvainlapoix@gmail.com).
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
